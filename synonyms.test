<?php

/**
 * @file
 * Tests for the Synonyms module.
 */

/**
 * Base class for all Synonyms web test cases.
 */
abstract class SynonymsWebTestCase extends DrupalWebTestCase {

  /**
   * Fully loaded user object of an admin user that has required access rights.
   *
   * @var object
   */
  protected $admin;

  /**
   * Taxonomy vocabulary within which the whole testing happens.
   *
   * @var object
   */
  protected $vocabulary;

  /**
   * Text fields that can be used for general purpose testing of behaviors.
   *
   * The var is firstly keyed by either 'enabled' or 'disabled', correspondingly
   * representing whether the behavior is enabled or disabled on that field. And
   * the inner array has 2 keys:
   * - field: (array) field definition array
   * - instance: (array) instance definition array
   *
   * @var array
   */
  protected $fields = array(
    'enabled' => array(
      'field' => array(
        'field_name' => 'text_enabled',
        'type' => 'text',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      ),
      'instance' => array(
        'entity_type' => 'taxonomy_term',
      ),
    ),
    'disabled' => array(
      'field' => array(
        'field_name' => 'text_disabled',
        'type' => 'text',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      ),
      'instance' => array(
        'entity_type' => 'taxonomy_term',
      ),
    ),
  );

  /**
   * Name of a synonyms behavior that is being tested.
   *
   * @var string
   */
  protected $behavior;

  /**
   * Settings for the behavior that is being tested.
   *
   * @var array
   */
  protected $behavior_settings = array();

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $modules[] = 'synonyms';
    parent::setUp($modules);

    $this->admin = $this->drupalCreateUser(array(
      'administer taxonomy',
      'administer content types',
      'bypass node access',
      'search content',
    ));

    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    $this->vocabulary = (object) array(
      'name' => $this->randomName(),
      'machine_name' => 'synonyms_test',
      'description' => $this->randomName(),
    );
    taxonomy_vocabulary_save($this->vocabulary);

    $this->fields['enabled']['field'] = field_create_field($this->fields['enabled']['field']);
    $this->fields['enabled']['field'] = field_info_field($this->fields['enabled']['field']['field_name']);
    $this->fields['enabled']['instance']['bundle'] = $this->vocabulary->machine_name;
    $this->fields['enabled']['instance']['field_name'] = $this->fields['enabled']['field']['field_name'];
    $this->fields['enabled']['instance'] = field_create_instance($this->fields['enabled']['instance']);
    $this->fields['enabled']['instance'] = field_info_instance($this->fields['enabled']['instance']['entity_type'], $this->fields['enabled']['instance']['field_name'], $this->fields['enabled']['instance']['bundle']);

    $this->fields['disabled']['field'] = field_create_field($this->fields['disabled']['field']);
    $this->fields['disabled']['field'] = field_info_field($this->fields['disabled']['field']['field_name']);
    $this->fields['disabled']['instance']['bundle'] = $this->vocabulary->machine_name;
    $this->fields['disabled']['instance']['field_name'] = $this->fields['disabled']['field']['field_name'];
    $this->fields['disabled']['instance'] = field_create_instance($this->fields['disabled']['instance']);
    $this->fields['disabled']['instance'] = field_info_instance($this->fields['disabled']['instance']['entity_type'], $this->fields['disabled']['instance']['field_name'], $this->fields['disabled']['instance']['bundle']);

    synonyms_behavior_settings_save(array(
      'instance_id' => $this->fields['enabled']['instance']['id'],
      'behavior' => $this->behavior,
      'settings' => $this->behavior_settings,
    ));
  }

  /**
   * Return last inserted term into the specified vocabulary.
   *
   * @param object $vocabulary
   *   Fully loaded taxonomy vocabulary object
   *
   * @return object
   *   Fully loaded taxonomy term object of the last inserted term into
   *   the specified vocabulary
   */
  protected function getLastTerm($vocabulary) {
    $tid = db_select('taxonomy_term_data', 't');
    $tid->addExpression('MAX(t.tid)');
    $tid->condition('vid', $vocabulary->vid);
    $tid = $tid->execute()->fetchField();
    return entity_load_unchanged('taxonomy_term', $tid);
  }
}

/**
 * Test Synonyms functionality of synonyms module.
 */
class SynonymsSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'synonyms';

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms',
      'description' => 'Ensure that the general "synonyms" behavior works correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * Test the functionality of synonyms.
   */
  public function testSynonyms() {
    $name = $this->randomName();
    $synonym = $this->randomName();
    $parent_synonym = $this->randomName();

    // Creating terms for testing synonyms_get_term_synonyms().
    $synonym1 = $this->randomName();
    $synonym2 = $this->randomName();

    $no_synonyms_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      'description' => $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($no_synonyms_term);

    $one_synonym_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $synonym1)),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($one_synonym_term);

    $two_synonyms_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name'=> $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($two_synonyms_term);

    // Creating an identical parent term in order to test $parent parameter in
    // our functions.
    $term_parent = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
          array('value' => $parent_synonym),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($term_parent);

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      'parent' => $term_parent->tid,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($term);

    // Testing the 'synonyms' property of 'taxonomy_term' entity.
    $synonyms = synonyms_get_sanitized($no_synonyms_term);
    $this->assertTrue(empty($synonyms), 'Successfully retrieved synonyms_get_sanitized() for a term without synonyms.');
    $synonyms = synonyms_get_sanitized($one_synonym_term);
    $this->assertTrue(count($synonyms) == 1 && $synonyms[0] == $synonym1, 'Successfully retrieved synonyms_get_sanitized() for a term with a single synonym.');
    $synonyms = synonyms_get_sanitized($two_synonyms_term);
    $this->assertTrue(count($synonyms) == 2 && $synonyms[0] == $synonym1 && $synonyms[1] == $synonym2, 'Successfully retrieved synonyms_get_sanitized() for a term with 2 synonyms.');

    // Testing the function synonyms_get_term_by_synonym().
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($synonym), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully looked up term by its synonym.');
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($name), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully looked up term by its name.');
    // Now submitting a non-existing name.
    $tid = synonyms_get_term_by_synonym($parent_synonym, $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 if the term is not found (due to $parent parameter).');

    $tid = synonyms_get_term_by_synonym($term->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->vocabulary);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 if the term is not found (due to a field not being engaged in "synonyms" behavior).');

    // Testing the function synonyms_add_term_by_synonym().
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($name), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on an existing title and no new term was created.');
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($synonym), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on an existing synonym and no new term was created.');
    drupal_static_reset();
    $tid = synonyms_add_term_by_synonym($parent_synonym, $this->vocabulary, $term_parent->tid);
    $new_term = taxonomy_term_load($tid);
    $new_term_parents = array_keys(taxonomy_get_parents($new_term->tid));
    $this->assertEqual($parent_synonym, $new_term->name, 'Successfully called synonyms_add_term_by_synonym() on a new title and a new term was created (due to parent restriction).');
    $this->assertNotEqual($new_term->tid, $term_parent->tid, 'Successfully called synonyms_add_term_by_synonym() on a synonym of $parent. New term was created instead of returning $parent\'s tid.');
    $this->assertTrue(in_array($term_parent->tid, $new_term_parents), 'Successfully called synonyms_add_term_by_synonym(). New term is assigned as a child to supplied $parent parameter.');

    $tid = synonyms_add_term_by_synonym($term->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->vocabulary);
    $new_term = taxonomy_term_load($tid);
    $this->assertNotEqual($new_term->tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on a new title and a new term was created (due to a field not being engaged in "synonyms" behavior).');
  }
}

/**
 * Test "Synonyms friendly autocomplete" widget of Synonyms module.
 */
class AutocompleteSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'autocomplete';

  protected $behavior_settings = array(
    'wording' => '@synonym @field_name @term',
  );

  /**
   * Array of fully loaded taxonomy term entities to be used in this test.
   *
   * @var array
   */
  protected $terms = array();

  /**
   * Entity type to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $entity_type = 'node';

  /**
   * Bundle to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $bundle = 'synonyms_test_content';

  /**
   * Field definition array of the field that will be attached to
   * $this->entity_type with synonyms-friendly autocomplete widget.
   *
   * @var array
   */
  protected $term_reference_field = array();

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms autocomplete',
      'description' => 'Ensure that the "synonym friendly autocomplete" widget works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => $this->bundle,
    ), 'Save content type');

    $this->term_reference_field = array(
      'type' => 'taxonomy_term_reference',
      'field_name' => 'synonyms_term_enabled',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    $this->term_reference_field = field_create_field($this->term_reference_field);

    $instance = array(
      'field_name' => $this->term_reference_field['field_name'],
      'entity_type' => 'node',
      'bundle' => $this->bundle,
      'label' => 'Synonym Terms Autcomplete',
      'widget' => array(
        'type' => 'synonyms_autocomplete',
      ),
    );
    $instance = field_create_instance($instance);

    drupal_static_reset();

    // Now creating taxonomy tree.
    $name = $this->randomName();

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['term1'] = $term;

    $name .= $this->randomName();

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name'=> $name,
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['term1_longer_name'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['no_synonyms'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['one_synonym'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['two_synonyms'] = $term;

    $name = $this->randomName();
    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['name_similar_synonym'] = $term;

    $name = 'similar_synonyms_';
    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['similar_synonyms'] = $term;

    $name = 'one_term_name_another_synonym_';

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name . $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['name_another_synonym'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['synonym_another_name'] = $term;
  }

  /**
   * Test auto-creation functionality.
   *
   * Test the auto-creation functionality of the synonym friendly autocomplete
   * widget type. Along the way it tests whether synonyms, submitted into the
   * widget's textfield are converted into the terms, synonyms of which they
   * are.
   */
  public function testAutoCreation() {
    // Trying enabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => TRUE,
    ), 'Save settings');

    $new_term_name = $this->terms['no_synonyms']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'];
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'synonyms_term_enabled[' . LANGUAGE_NONE . ']' => $this->terms['no_synonyms']->name . ', ' . $new_term_name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    ), 'Save');
    $this->assertText($this->terms['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertText($new_term_name, 'Auto created term was assigned to the new node when Auto creation is on.');
    $this->assertText($this->terms['one_synonym']->name, 'Submitting a synonym into autocomplete widget results in the term, to which the synonym belongs, being assigned to the just created entity (when Auto creation is on).');
    $term = $this->getLastTerm($this->vocabulary);
    $this->assertEqual($term->name, $new_term_name, 'The auto created term has been created when Auto creation is on.');

    // Trying disabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => FALSE,
    ), 'Save settings');

    $new_term_name = $this->terms['term1']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'];
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'synonyms_term_enabled[' . LANGUAGE_NONE . ']' => $this->terms['no_synonyms']->name . ', ' . $new_term_name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    ), 'Save');
    $this->assertText($this->terms['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertNoText($new_term_name, 'Auto created term was not assigned to the new node when Auto creation is off.');
    $this->assertText($this->terms['one_synonym']->name, 'Submitting a synonym into autocomplete widget results in the term, to which the synonym belongs, being assigned to the just created entity (when Auto creation is off).');
    $term = $this->getLastTerm($this->vocabulary);
    $this->assertNotEqual($term->name, $new_term_name, 'The auto created term has not been created when Auto creation is off.');
  }

  /**
   * Test autocomplete menu path.
   *
   * Feed all known "buggy" input to synonym friendly autocomplete menu path,
   * in order to test its performance.
   */
  public function testAutocompleteMenuPath() {
    $this->assertAutocompleteMenuPath('', array(), 'Submitting empty string into autocomplete path returns empty result.');
    $this->assertAutocompleteMenuPath($this->randomName(), array(), 'Submitting a non existing name into autocomplete path returns empty result.');
    $this->assertAutocompleteMenuPath($this->terms['term1']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], array(), 'Submitting a value for a field with disabled autocomplete behavior yields empty result.');

    $this->assertAutocompleteMenuPath(drupal_strtoupper(drupal_substr($this->terms['term1']->name, 1, -1)), array(
      $this->terms['term1']->name => $this->terms['term1']->name,
      $this->terms['term1_longer_name']->name => $this->terms['term1_longer_name']->name,
    ), 'Submitting a name similar to 2 existing term names yields both terms included in the autocomplete response.');

    $this->assertAutocompleteMenuPath($this->terms['term1']->name . ', ' . drupal_strtoupper(drupal_substr($this->terms['term1']->name, 1, -1)), array(
      $this->terms['term1']->name . ', ' . $this->terms['term1_longer_name']->name => $this->terms['term1_longer_name']->name,
    ), 'Submitting one term already chosen along with a name similar to 2 existing term names yields only suggested a new term.');

    $this->assertAutocompleteMenuPath(drupal_strtoupper(drupal_substr($this->terms['no_synonyms']->name, 1, -1)), array(
      $this->terms['no_synonyms']->name => $this->terms['no_synonyms']->name,
    ), 'Submitting a name similar to one existing term name into autocomplete path yields that term included.');

    $this->assertAutocompleteMenuPath(drupal_strtolower($this->terms['no_synonyms']->name) . ', ' . drupal_strtoupper(drupal_substr($this->terms['no_synonyms']->name, 1, -1)), array(), 'Submitting the same term over again into autocomplete path yields no results.');

    $this->assertAutocompleteMenuPath($this->terms['one_synonym']->name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], array(), 'Submitting a synonym of a term over again into autocomplete path yields no results.');

    foreach (array('no_synonyms', 'one_synonym', 'two_synonyms') as $k) {
      $this->assertAutocompleteMenuPath(drupal_strtolower(drupal_substr($this->terms[$k]->name, 1, -1)), array(
        $this->terms[$k]->name => $this->terms[$k]->name,
      ), 'Submitting a name similar to ' . $k . ' term into autocomplete path yields the term included.');

      $synonyms = field_get_items('taxonomy_term', $this->terms[$k], $this->fields['enabled']['field']['field_name']);
      if (is_array($synonyms)) {
        foreach ($synonyms as $delta => $item) {
          $this->assertAutocompleteMenuPath(drupal_strtolower(drupal_substr($item['value'], 1, -1)), array(
            $this->terms[$k]->name => $this->synonymAutocompleteResult($this->terms[$k], $item['value'], $this->fields['enabled']['instance']),
          ), 'Submitting a name similar to synonym#' . $delta . ' of the term ' . $k . ' into autocomplete path yields the term included.');
        }
      }
    }

    $this->assertAutocompleteMenuPath('one_term_name_another_synonym_', array(
      $this->terms['name_another_synonym']->name => $this->terms['name_another_synonym']->name,
      $this->terms['synonym_another_name']->name => $this->synonymAutocompleteResult($this->terms['synonym_another_name'], $this->terms['synonym_another_name']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Submitting a name similar to name of one term and synonym of another into autocomplete path yields both terms included.');
  }

  /**
   * Test 'Suggestions Size' setting of synonyms-friendly autocomplete widget.
   */
  public function testWidgetSettingsSuggestionSize() {
    $suggestion_size = 1;
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][suggestion_size]' => $suggestion_size,
    ), 'Save settings');

    // If size was bigger than 1, we'd get suggested 2 terms: 'term1' and
    // 'term1_longer_name'.
    $this->assertAutocompleteMenuPath($this->terms['term1']->name, array(
      $this->terms['term1']->name => $this->terms['term1']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for term suggestion entries.');

    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for term and synonym suggestion entries.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Suggestions Size option is respected in autocomplete widget for synonyms suggestion entries.');

    $this->assertAutocompleteMenuPath('one_term_name_another_synonym_', array(
      $this->terms['name_another_synonym']->name => $this->terms['name_another_synonym']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for the case when there is match by term name and by synonyms; and preference is given to the match by term name.');
  }

  /**
   * Test 'Suggest only one entry per term' setting of autocomplete widget.
   */
  public function testWidgetSettingsSuggestOnlyUnique() {
    // Testing disabled "Suggest only one entry per term" setting.
    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
      $this->terms['name_similar_synonym']->name . ' ' => $this->synonymAutocompleteResult($this->terms['name_similar_synonym'], $this->terms['name_similar_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Both term and its synonym are shown when "Suggest only one entry per term" is off.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
      $this->terms['similar_synonyms']->name . ' ' => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'], $this->fields['enabled']['instance']),
    ), 'Multiple synonyms are shown when "Suggest only one entry per term" is off.');

    // Testing enabled "Suggest only one entry per term" setting.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][suggest_only_unique]' => TRUE,
    ), 'Save settings');

    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
    ), 'Only term is shown and synonym is not shown when "Suggest only one entry per term" is on.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Only single synonym is shown when "Suggest only one entry per term" is on.');
  }

  /**
   * Assert output of synonym friendly autocomplete path.
   *
   * @param string $input
   *   String of input to supply to the autocomplete path
   * @param array $standard
   *   Expected output from the autocomplete path. Supply it as an associative
   *   array
   * @param string $message
   *   Drupal assertion message to be displayed on the rest results page
   */
  protected function assertAutocompleteMenuPath($input, $standard, $message) {
    $response = $this->drupalGet('synonyms/autocomplete/' . $this->term_reference_field['field_name']  . '/' . $this->entity_type . '/' . $this->bundle . '/' . $input);
    if (!$response) {
      $this->fail($message, 'Autocomplete Menu Path');
      return;
    }
    $response = (array) json_decode($response);
    $is_the_same = count($response) == count($standard);
    $is_the_same = $is_the_same && count(array_intersect_assoc($response, $standard)) == count($standard);

    $this->assertTrue($is_the_same, $message, 'Autocomplete Menu Path');
  }

  /**
   * Return expected autocomplete menu path result.
   *
   * The result is prepared as if the term was found by the supplied synonym.
   *
   * @param object $term
   *   Fully loaded taxonomy term object for which the result is generated.
   * @param string $synonym
   *   Synonym by which the term was hit in the search
   * @param array $instance
   *   Instance definition array which the $synonym originates from
   *
   * @return string
   *   Formatted autocomplete result
   */
  protected function synonymAutocompleteResult($term, $synonym, $instance) {
    return format_string($this->behavior_settings['wording'], array(
      '@synonym' => $synonym,
      '@term' => $term->name,
      '@field_name' => drupal_strtolower($instance['label']),
    ));
  }
}

/**
 * Test Synonyms module integration with Drupal search functionality.
 */
class SearchIndexSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'search';

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Synonyms search integration',
      'description' => 'Ensure that Synonyms module correctly integrates with the Drupal search functionality.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => 'synonyms_test_content',
    ), 'Save content type');

    // Attaching term reference field to the new content type.
    $field = array(
      'type' => 'taxonomy_term_reference',
      'field_name' => 'synonyms_term_enabled',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    $field = field_create_field($field);

    $instance = array(
      'field_name' => $field['field_name'],
      'entity_type' => 'node',
      'bundle' => 'synonyms_test_content',
      'label' => 'Synonym Terms',
      'widget' => array(
        'type' => 'synonyms_autocomplete',
      ),
    );

    $instance = field_create_instance($instance);
  }

  /**
   * Test searching by a term synonym.
   *
   * Since logically term and its synonyms represent the same entity, the idea
   * is that searching by a term synonym should trigger all content referencing
   * that term to be included in search results. Additionally we test that when
   * a synonym is deleted/edited in a term, corresponding content is no longer
   * encountered when searched by ex-synonym.
   */
  public function testSearchTermSynonym() {
    // Create a few terms and synonyms.
    $terms = array();
    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $terms['no_synonyms'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $terms['one_synonym'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $terms['two_synonyms'] = $term;

    // Creating a node, which references to all the terms we have.
    $node = (object) array(
      'type' => 'synonyms_test_content',
      'title' => $this->randomName(),
      'synonyms_term_enabled' => array(LANGUAGE_NONE => array(
        array('tid' => $terms['no_synonyms']->tid),
        array('tid' => $terms['one_synonym']->tid),
        array('tid' => $terms['two_synonyms']->tid),
      )),
    );
    node_save($node);

    // Rebuilding Search index.
    $this->cronRun();

    foreach ($terms as $k => $term) {
      $this->assertSearchResults($term->name, array($node), 'Searching by name of the term ' . $k);
      $items = field_get_items('taxonomy_term', $term, $this->fields['disabled']['field']['field_name']);
      if (is_array($items)) {
        foreach ($items as $delta => $item) {
          $this->assertSearchResults($item['value'], array(), 'Searching by not enabled search integration field value #' . $delta . ' of term ' . $k);
        }
      }

      $items = field_get_items('taxonomy_term', $term, $this->fields['enabled']['field']['field_name']);
      if (is_array($items)) {
        foreach ($items as $delta => $item) {
          $this->assertSearchResults($item['value'], array($node), 'Searching by synonym #' . $delta . ' of the term ' . $k);
        }
      }
    }

    // Removing a synonym from the term. Then asserting node got re-indexed with
    // new values of synonyms.
    $deleted_synonym = array_pop($terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE]);
    taxonomy_term_save($terms['one_synonym']);
    $this->cronRun();
    $this->assertSearchResults($deleted_synonym['value'], array(), 'Searching by recently deleted synonym of a taxonomy term yields no results.');

    // Editing a synonym in a term. Then asserting node got re-indexed with new
    // values of synonyms.
    $ex_synonym = $terms['two_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'];
    $terms['two_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'] = $this->randomName();
    taxonomy_term_save($terms['two_synonyms']);
    $this->cronRun();
    $this->assertSearchResults($ex_synonym, array(), 'Searching by recently changed synonym of a taxonomy term yields no results.');

    // We disable entire field from search integration and make sure for all
    // synonyms search results are empty.
    synonyms_behavior_settings_delete($this->fields['enabled']['instance']['id'], $this->behavior);
    $this->cronRun();
    foreach ($terms as $k => $term) {
      $items = field_get_items('taxonomy_term', $term, $this->fields['enabled']['field']['field_name']);
      if (is_array($items)) {
        foreach ($items as $synonym) {
          $this->assertSearchResults($synonym['value'], array(), 'Searching by ' . $k . ' term synonym, which field was recently disabled from search behavior yields no results.');
        }
      }
    }
  }

  /**
   * Assert search results.
   *
   * @param $keyword string
   *   Keyword to supply to the search mechanism
   * @param $results array
   *   Array of fully loaded nodes that are expected to be on search results
   * @param $message string
   *   Drupal assertion message to display on test results page
   */
  protected function assertSearchResults($keyword, $results, $message) {
    $response = $this->drupalGet('search/node/' . $keyword);
    $matches = array();
    preg_match_all('#\<li[^>]+class="search-result"[^>]*\>(.*?)\</li\>#si', $response, $matches);
    $matches = $matches[1];
    if (count($matches) != count($results)) {
      $this->fail($message);
      return;
    }
    $matches = implode('', $matches);
    foreach ($results as $node) {
      if (strpos($matches, 'node/' . $node->nid) === FALSE) {
        $this->fail($message);
        return;
      }
    }
    $this->pass($message);
  }
}

/**
 * Base class for all tests that test Synonyms behavior implementation classes.
 */
abstract class AbstractSynonymsBehaviorWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'synonyms';

  /**
   * Test synonymsExtract() method.
   *
   * @param array $items
   *   Array of field items to be saved in tested term
   * @param array $standard
   *   Expected return of synonymsExtract() method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertSynonymsExtract($items, $standard, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $term = (object) array(
      'name' => $this->randomName(),
      'vid' => $this->vocabulary->vid,
    );
    $term->{$this->fields['enabled']['field']['field_name']} = $items;
    taxonomy_term_save($term);
    $items = field_get_items('taxonomy_term', $term, $this->fields['enabled']['field']['field_name']);

    $synonyms = is_array($items) ? $behavior_implementation->extractSynonyms($items, $this->fields['enabled']['field'], $this->fields['enabled']['instance'], $term, 'taxonomy_term') : array();
    $this->assertTrue(count(array_intersect($standard, $synonyms)) == count($standard), get_class($behavior_implementation) . '::extractSynonyms() passed: ' . $message);
    // Cleaning up.
    taxonomy_term_delete($term->tid);
  }

  /**
   * Test processEntityFieldQuery method.
   *
   * @param array $meta_data
   *   Array of meta data. Each subarray represents a single term and whether it
   *   is expected to be included in the results of EntityFieldQuery. Should
   *   have the following structure:
   *   - items: (array) Array of field items. Terms will be automatically
   *     created with those items
   *   - expected: (bool) Whether the created term should be expected in the
   *     results of EntityFieldQuery
   * @param string $tag
   *   Corresponding parameter to be passed to processEntityFieldQuery() method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertProcessEntityFieldQuery($meta_data, $tag, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('autocomplete', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    // Creating taxonomy terms according to the meta data.
    $terms = array();
    foreach ($meta_data as $v) {
      $term = (object) array(
        'name' => $this->randomName(),
        'vid' => $this->vocabulary->vid,
      );
      taxonomy_term_save($term);
      $term->{$this->fields['enabled']['field']['field_name']} = $v['items'];
      taxonomy_term_save($term);
      $term->expected = $v['expected'];
      $terms[] = $term;
    }
    // Preparing and running EntityFieldQuery.
    $efq = new EntityFieldQuery();
    $efq->entityCondition('entity_type', 'taxonomy_term')
        ->entityCondition('bundle', $this->vocabulary->machine_name);
    if ($behavior_implementation->processEntityFieldQuery($tag, $efq, $this->fields['enabled']['field'], $this->fields['enabled']['instance'])) {
      $result = $efq->execute();
      $result = isset($result['taxonomy_term']) ? array_keys($result['taxonomy_term']) : array();
    }
    else {
      $result = array();
    }
    // Asserting results of EntityFieldQuery.
    $pass = TRUE;
    foreach ($terms as $term) {
      $tmp = $term->expected ? in_array($term->tid, $result) : !in_array($term->tid, $result);
      $pass = $pass && $tmp;
    }
    $this->assertTrue($pass, get_class($behavior_implementation) . '::processEntityFieldQuery() passed: ' . $message);

    // Cleaning up.
    foreach ($terms as $term) {
      taxonomy_term_delete($term->tid);
    }
  }

  /**
   * Test mergeEntityAsSynonym method.
   *
   * @param array $items
   *   Parameter will be passed directly to the behavior implementation object
   * @param object $synonym_entity
   *   Parameter will be passed directly to the behavior implementation object
   * @param string $synonym_entity_type
   *   Parameter will be passed directly to the behavior implementation object
   * @param array $standard
   *   Array that is expected to be returned by the tested method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertMergeEntityAsSynonym($items, $synonym_entity, $synonym_entity_type, $standard, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $message = get_class($behavior_implementation) . '::mergeEntityAsSynonym() passed: ' . $message;

    $extra_items = $behavior_implementation->mergeEntityAsSynonym($items, $this->fields['enabled']['field'], $this->fields['enabled']['instance'], $synonym_entity, $synonym_entity_type);
    foreach ($standard as $k => $v) {
      if (count(array_intersect($standard[$k], $extra_items[$k])) != count($standard[$k])) {
        $this->fail($message);
        return;
      }
    }
    $this->pass($message);
  }


  /**
   * Test synonymFind method.
   *
   * @param array $meta_data
   *   Array of meta data. Each subarray represents a single term and whether it
   *   is expected to be included in the return of the method. Should have the
   *   following structure:
   *   - items: (array) Array of field items. Terms will be automatically
   *     created with those items
   *   - expected: (bool) Whether the created term should be expected in the
   *     results of EntityFieldQuery
   * @param string $synonym
   *   Parameter will be passed directly to the extractor class method
   * @param string $message
   *   Any custom message to be added tot he standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertSynonymFind($meta_data, $synonym, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $message = get_class($behavior_implementation) . '::synonymFind() pass: ' . $message;

    $terms = array();
    $expected_count = 0;
    foreach ($meta_data as $v) {
      $term = (object) array(
        'name' => $this->randomName(),
        'vid' => $this->vocabulary->vid,
        $this->fields['enabled']['field']['field_name'] => $v['items'],
      );
      taxonomy_term_save($term);
      $term->expected = $v['expected'];
      if ($term->expected) {
        $expected_count++;
      }
      $terms[] = $term;
    }

    $return = $behavior_implementation->synonymFind($synonym, $this->fields['enabled']['field'], $this->fields['enabled']['instance']);
    $success = count($return) == $expected_count;

    foreach ($terms as $term) {
      if ($term->expected xor in_array($term->tid, $return)) {
        $success = FALSE;
      }
    }

    $this->assertTrue($success, $message);

    // Cleaning up.
    foreach ($terms as $term) {
      taxonomy_term_delete($term->tid);
    }
  }
}

/**
 * Test TextSynonymsBehavior class.
 */
class TextSynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'TextSynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from text and number fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * Test synonyms extraction for 'text' field type.
   */
  public function testText() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym = $this->randomName();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array('value' => $synonym),
      ),
    ), array($synonym), 'on a field that holds one value.');

    // Testing processEntityFieldQuery().
    $this->assertProcessEntityFieldQuery(array(), $this->randomName(), 'on empty field.');

    $tag = $this->randomName();
    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          0 => array('value' => $tag . $this->randomName()),
          1 => array('value' => $this->randomName()),
        ),
      ),
      'expected' => TRUE,
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          0 => array('value' => $this->randomName()),
        ),
      ),
      'expected' => FALSE,
    );
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertProcessEntityFieldQuery($meta_data, $tag, 'on a field with values.');

    // Testing mergeEntityAsSynonym() method.
    $node = (object) array(
      'title' => $this->randomName(),
      'type' => 'page',
    );
    node_save($node);
    $this->assertMergeEntityAsSynonym(array(), $node, 'node', array(array('value' => $node->title)), 'on a node entity.');

    // Testing synonymFind() method.
    $this->assertSynonymFind(array(), $this->randomName(), 'on empty field.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field without synonyms.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field with a synonym, but when searching for another keyword.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
          array('value' => $this->randomName()),
        ),
      ),
      'expected' => FALSE,
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      'expected' => TRUE,
    );
    $this->assertSynonymFind($meta_data, $meta_data[1]['items'][LANGUAGE_NONE][0]['value'], 'on a field with synonym, when searching for this synonym.');
  }
}

/**
 * Test TaxonomySynonymsBehavior class.
 */
class TaxonomySynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * Taxonomy vocabulary object terms.
   *
   * Terms of this vocabulary are synonyms of the main vocabulary terms.
   *
   * @var object
   */
  protected $vocabularySource;

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'TaxonomySynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from taxonomy term reference fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $this->fields['enabled']['field'] = array(
      'field_name' => 'term',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'type' => 'taxonomy_term_reference',
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => 'source_vocabulary',
            'parent' => 0,
          ),
        ),
      ),
    );
    parent::setUp($modules);

    $this->vocabularySource = (object) array(
      'name' => $this->randomName(),
      'machine_name' => 'source_vocabulary',
    );
    taxonomy_vocabulary_save($this->vocabularySource);
  }

  /**
   * Test synonyms extraction for 'taxonomy_term_reference' field type.
   */
  public function testTaxonomyTermReference() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym_term = $this->createSynonymTerm();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array(
          'tid' => $synonym_term->tid,
        ),
      ),
    ), array($synonym_term->name), 'on a field that holds one value.');

    // Testing processEntityFieldQuery().
    $this->assertProcessEntityFieldQuery(array(), $this->randomName(), 'on empty field.');

    $tag = $this->randomName();
    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm($tag . $this->randomName())->tid),
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'expected' => TRUE,
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'expected' => FALSE,
    );
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertProcessEntityFieldQuery($meta_data, $tag, 'on a field with values.');

    // Testing mergeEntityAsSynonym() method.
    $synonym_term = $this->createSynonymTerm();
    $this->assertMergeEntityAsSynonym(array(), $synonym_term, 'taxonomy_term', array(array('tid' => $synonym_term->tid)), 'on a term from referenced vocabulary.');

    // Testing synonymFind() method.
    $this->assertSynonymFind(array(), $this->randomName(), 'on empty field.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field without synonyms.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field with a synonym, but when searching for another keyword.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'expected' => FALSE,
    );
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term->tid),
        ),
      ),
      'expected' => TRUE,
    );
    $this->assertSynonymFind($meta_data, $synonym_term->name, 'on a field with synonym, when searching for this synonym.');
  }

  /**
   * Supportive function.
   *
   * Create a taxonomy term in the synonyms source vocabulary with the specified
   * name.
   *
   * @param string $name
   *   Name of the term to be created. If nothing is supplied a random string
   *   is used
   *
   * @return object
   *   Fully loaded taxonomy term object of the just created term
   */
  protected function createSynonymTerm($name = NULL) {
    if (is_null($name)) {
      $name = $this->randomName();
    }
    $synonym_term = (object) array(
      'name' => $name,
      'vid' => $this->vocabularySource->vid,
    );
    taxonomy_term_save($synonym_term);
    return $synonym_term;
  }
}

/**
 * Test EntityReferenceSynonymsBehavior class.
 */
class EntityReferenceSynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'EntityReferenceSynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from entity reference fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $modules[] = 'entityreference';

    $this->fields['enabled']['field'] = array(
      'field_name' => 'reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'type' => 'entityreference',
      // For the sake of experiment we use entityreference field that references
      // nodes of a Drupal standard type to make things easier.
      'settings' => array(
        'target_type' => 'node',
        'handler' => 'base',
        'handler_settings' => array(
          'target_bundles' => array('page' => 'page'),
          'sort' => array('type' => 'none'),
        ),
      ),
    );

    parent::setUp($modules);
  }

  /**
   * Test synonyms extraction for 'entityreference' field type.
   */
  public function testEntityReference() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym_entity = $this->createNode();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array(
          'target_id' => entity_id('node', $synonym_entity),
        ),
      ),
    ), array(entity_label('node', $synonym_entity)), 'on a field that holds one value.');

    // Testing processEntityFieldQuery().
    $this->assertProcessEntityFieldQuery(array(), $this->randomName(), 'on empty field.');

    $tag = $this->randomName();
    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array(
            'target_id' => entity_id('node', $this->createNode($tag . $this->randomName())),
          ),
          array(
            'target_id' => entity_id('node', $this->createNode()),
          ),
        ),
      ),
      'expected' => TRUE,
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'expected' => FALSE,
    );
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertProcessEntityFieldQuery($meta_data, $tag, 'on a field with values.');

    // Testing mergeEntityAsSynonym() method.
    $node = $this->createNode();
    $this->assertMergeEntityAsSynonym(array(), $node, 'node', array(array('target_id' => $node->nid)), 'on a node.');

    // Testing synonymFind() method.
    $this->assertSynonymFind(array(), $this->randomName(), 'on empty field.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field without synonyms.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'expected' => FALSE,
    );
    $this->assertSynonymFind($meta_data, $this->randomName(), 'on a field with a synonym, but when searching for another keyword.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $this->createNode())),
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'expected' => FALSE,
    );
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
        ),
      ),
      'expected' => TRUE,
    );
    $this->assertSynonymFind($meta_data, entity_label('node', $synonym_entity), 'on a field with synonym, when searching for this synonym.');
  }

  /**
   * Supportive function.
   *
   * Create an entity of necessary entity type (in our test it's node).
   *
   * @param string $label
   *   Label to use for the entity that is about to be created
   * @param string $bundle
   *   Bundle to use for the entity that is about to be created
   *
   * @return object
   *   Fully loaded entity object of the just created entity
   */
  protected function createNode($label = NULL, $bundle = 'page') {
    if (is_null($label)) {
      $label = $this->randomName();
    }
    $entity = (object) array(
      'type' => $bundle,
      'title' => $label,
    );
    node_save($entity);
    return $entity;
  }
}
