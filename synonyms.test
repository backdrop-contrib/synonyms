<?php

/**
 * @file
 * Tests for the Synonyms module.
 */

/**
 * Base class for all Synonyms web test cases.
 */
class SynonymsWebTestCase extends DrupalWebTestCase {

  protected $admin;

  /**
   * SetUp method.
   */
  public function setUp() {
    parent::setUp(array('synonyms'));

    $this->admin = $this->drupalCreateUser(array(
      'administer taxonomy',
      'merge taxonomy terms',
      'administer content types',
      'bypass node access',
      'search content',
    ));
  }

  /**
   * Return last inserted term into the specified vocabulary.
   *
   * @param object $vocabulary
   *   Fully loaded taxonomy vocabulary object
   * @return object
   *   Fully loaded taxonomy term object of the last interted term into
   *     the specified vocabulary
   */
  protected function getLastTerm($vocabulary) {
    drupal_static_reset();
    $tree = taxonomy_get_tree($vocabulary->vid);
    $max = 0;
    $term = NULL;
    foreach ($tree as $k => $v) {
      if ($v->tid > $max) {
        $max = $v->tid;
        $term = $v;
      }
    }
    $term = entity_load_unchanged('taxonomy_term', $term->tid);
    return $term;
  }
}

/**
 * Test Synonyms functionality of synonyms module
 */
class SynonymsSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $vocabularies = array(
    'enabled' => TRUE,
    'disabled' => FALSE,
  );

  /**
   * GetInfo method.
   */
  public function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms',
      'description' => 'Ensure that the feature "synonyms" works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp() {
    parent::setUp();

    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    foreach ($this->vocabularies as $k => $v) {
      $name = $this->randomName();
      $this->drupalPost('admin/structure/taxonomy/add', array(
        'name' => $name,
        'machine_name' => $k,
        'description' => $this->randomName(),
        'synonyms[synonyms]' => $v,
      ), 'Save');
      $this->vocabularies[$k] = taxonomy_vocabulary_machine_name_load($k);
    }
    // Flushing static cache.
    _field_info_collate_fields(TRUE);
  }

  /**
   * Test the disabled taxonomy synonyms feature.
   */
  public function testSynonymsDisabled() {
    $this->drupalGet('admin/structure/taxonomy/disabled/add');
    $this->assertNoFieldById('edit-synonyms-synonyms-und-0-value');

    $this->drupalGet('admin/structure/taxonomy/enabled/add');
    $this->assertFieldById('edit-synonyms-synonyms-und-0-value');

    // Making sure that after disabling "synonyms" the synonyms field
    // is no longer available on taxonomy term add page.
    $this->drupalPost('admin/structure/taxonomy/enabled/edit', array(
      'synonyms[synonyms]' => FALSE,
    ), 'Save');

    $this->drupalGet('admin/structure/taxonomy/enabled/add');
    $this->assertNoFieldById('edit-synonyms-synonyms-und-0-value');
  }

  /**
   * Test the functionality of synonyms.
   */
  public function testSynonyms() {
    $name = $this->randomName();
    $synonym = $this->randomName();
    $parent_synonym = $this->randomName();

    // Creating terms for testing synonyms_get_term_synonyms().
    $synonym1 = $this->randomName();
    $synonym2 = $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'description[value]' => $this->randomName(),
    ), 'Save');
    $no_synonyms_term = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $synonym1,
    ), 'Save');
    $one_synonym_term = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $synonym1,
    ), 'Add another item');
    $this->drupalPost(NULL, array(
      'synonyms_synonyms[und][1][value]' => $synonym2,
    ), 'Save');
    $two_synonyms_term = $this->getLastTerm($this->vocabularies['enabled']);

    // Creating an identical parent term in order to test
    // $parent parameter in our functions.
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $name,
      'description[value]' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $synonym,
    ), 'Add another item');
    $this->drupalPost(NULL, array(
      'synonyms_synonyms[und][1][value]' => $parent_synonym,
    ), 'Save');
    $term_parent = $this->getLastTerm($this->vocabularies['enabled']);

    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $name,
      'description[value]' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $synonym,
      'parent[]' => array($term_parent->tid),
    ), 'Save');

    $term = $this->getLastTerm($this->vocabularies['enabled']);

    $this->drupalGet('taxonomy/term/' . $term->tid);
    // Asserting the presence of synonym string.
    $this->assertText($synonym, 'The synonym string is present on taxonomy term view page');

    // Testing the function synonyms_get_term_synonyms().
    $synonyms = synonyms_get_term_synonyms($no_synonyms_term);
    $this->assertTrue(empty($synonyms), 'Successfully called synonyms_get_term_synonyms() for a term without synonyms.');
    $synonyms = synonyms_get_term_synonyms($one_synonym_term);
    $this->assertTrue(count($synonyms) == 1 && $synonyms[0]['value'] == $synonym1, 'Sucessfully called synonyms_get_term_synonyms for a term with single synonym.');
    $synonyms = synonyms_get_term_synonyms($two_synonyms_term);
    $this->assertTrue(count($synonyms) == 2 && $synonyms[0]['value'] == $synonym1 && $synonyms[1]['value'] == $synonym2, 'Sucessfully called synonyms_get_term_synonyms for a term with 2 synonyms.');

    // Testing the function synonyms_get_term_by_synonym().
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($synonym), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Sucessfully looked up term by its synonym.');
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($name), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Sucessfully looked up term by its name.');
    // Now submitting a non-existing name.
    $tid = synonyms_get_term_by_synonym($parent_synonym, $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 if the term is not found (considering $parent parameter).');

    // Testing the function synonyms_add_term_by_synonym().
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($name), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Sucessfully called synonyms_add_term_by_synonym() on an existing title and no new term was created.');
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($synonym), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Sucessfully called synonyms_add_term_by_synonym() on an existing synonym and no new term was created.');
    drupal_static_reset();
    $tid = synonyms_add_term_by_synonym($parent_synonym, $this->vocabularies['enabled'], $term_parent->tid);
    $new_term = taxonomy_term_load($tid);
    $new_term_parents = array_keys(taxonomy_get_parents($new_term->tid));
    $this->assertEqual($parent_synonym, $new_term->name, 'Successfully called synonyms_add_term_by_synonym() on a new title and a new term was created.');
    $this->assertNotEqual($new_term->tid, $term_parent->tid, 'Successfully called synonyms_add_term_by_synonym() on a synonym of $parent. New term was created instead of returning $parent\'s tid.');
    $this->assertTrue(in_array($term_parent->tid, $new_term_parents), 'Successfully called synonyms_add_term_by_synonym(). New term is assigned as a child to supplied $parent parameter.');

    // Disabling functionality of synonyms for "enabled" vocabulary
    // and making sure it has cleaned up all its functionality.
    $this->drupalPost('admin/structure/taxonomy/enabled/edit', array(
      'synonyms[synonyms]' => FALSE,
    ), 'Save');

    $this->drupalGet('taxonomy/term/' . $term->tid);
    // Asserting the absence of synonym string.
    $this->assertNoText($synonym, 'The synonym string is no longer present on taxonomy term view page after disabling "synonyms" feature for a vocabulary');
    $term = array_pop(entity_load('taxonomy_term', array($term->tid), array(), TRUE));
    $this->assertFalse(isset($term->synonyms_synonyms), 'The term no longer has synonyms after disabling "synonyms" feature for a vocabulary');

    // Testing synonyms_get_term_synonums() function.
    $synonyms = synonyms_get_term_synonyms($no_synonyms_term);
    $this->assertTrue(empty($synonyms), 'Successfully called synonyms_get_term_synonyms() on a term without synonyms after disabling "synonyms" feature');
    $synonyms = synonyms_get_term_synonyms($one_synonym_term);
    $this->assertTrue(empty($synonyms), 'Successfully called synonyms_get_term_synonyms() on a term with single synonym after disabling "synonyms" feature');
    $synonyms = synonyms_get_term_synonyms($two_synonyms_term);
    $this->assertTrue(empty($synonyms), 'Successfully called synonyms_get_term_synonyms() on a term with 2 synonyms after disabling "synonyms" feature');

    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($synonym), $this->vocabularies['enabled']);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 after disabling "synonyms" feature for a vocabulary');
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($name), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'synonyms_get_term_by_synonym() returns $term->tid even after disabling "synonyms" feature if looking up by term title');

    // Testing synonyms_add_term_by_synonym() function.
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($name), $this->vocabularies['enabled'], $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on an existing title and no new term was created after disabling "synonyms" feature.');
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($synonym), $this->vocabularies['enabled'],  $term_parent->tid);
    $new_term = taxonomy_term_load($tid);
    $new_term_parents = array_keys(taxonomy_get_parents($new_term->tid));
    $this->assertFalse(in_array($new_term->tid, array($term->tid, $term_parent->tid)), 'Successfully called synonyms_add_term_by_synonym() using previous synonym and a new term was created (because the vocabulary has disabled "synonyms" feature)');
    $this->assertTrue(in_array($term_parent->tid, $new_term_parents), 'Successfully called synonyms_add_term_by_synonym(). New term is assigned as a child to supplied $parent parameter with disabled "synonyms" feature.');

    $tid = synonyms_add_term_by_synonym($parent_synonym, $this->vocabularies['enabled']);
    $new_term = array_pop(entity_load('taxonomy_term', array($tid), array(), TRUE));
    $this->assertEqual($parent_synonym, $new_term->name, 'Successfully called synonyms_add_term_by_synonym() on an new title and a new term was created.');
    $this->assertFalse(in_array($new_term->tid, array($term->tid, $term_parent->tid)), 'Successfully called synonyms_add_term_by_synonym() on the synonyn of parent term. New term was created (because the vocabulary has disabled "synonyms" feature)');
  }
}

/**
 * Test "term merge" functionality of Synonyms module.
 */
class TermMergeSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $vocabularies = array(
    'enabled' => TRUE,
    'disabled' => FALSE,
  );

  /**
   * GetInfo method.
   */
  public function getInfo() {
    return array(
      'name' => 'Taxonomy term merge',
      'description' => 'Ensure that the feature "term merge" works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp() {
    parent::setUp();

    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    foreach ($this->vocabularies as $k => $v) {
      $name = $this->randomName();
      $this->drupalPost('admin/structure/taxonomy/add', array(
        'name' => $name,
        'machine_name' => $k,
        'description' => $this->randomName(),
        'synonyms[term_merge]' => $v,
      ), 'Save');
      $this->vocabularies[$k] = taxonomy_vocabulary_machine_name_load($k);
    }
    // Flushing static cache.
    _field_info_collate_fields(TRUE);
  }

  /**
   * Test absence of "term merge" functionality.
   */
  public function testTermMergeDisabled() {
    $name = $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/disabled/add', array(
      'name' => $name,
    ), 'Save');
    $term = array_pop(taxonomy_get_term_by_name($name));

    $this->drupalGet('taxonomy/term/' . $term->tid . '/merge');
    $this->assertResponse(403, 'Merge is not allowed with "term merge" functionality disabled for a vocabulary');

    // Making sure that after disabling "term merge" the Merge tab
    // is no longer available on taxonomy term view page.
    $name = $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $name,
    ), 'Save');
    $term = array_pop(taxonomy_get_term_by_name($name));

    $this->drupalPost('admin/structure/taxonomy/enabled/edit', array(
      'synonyms[term_merge]' => FALSE,
    ), 'Save');

    $this->drupalGet('taxonomy/term/' . $term->tid . '/merge');
    $this->assertResponse(403, 'Merge is not allowed after disabling "term merge" functionality for a vocabulary');
  }

  /**
   * Test merging two terms.
   */
  public function testTermMerge() {
    // Attaching fields to taxonomy terms.
    $bundle = field_extract_bundle('taxonomy_term', $this->vocabularies['enabled']);
    $fields_map = array(
      'synonyms_test_single' => 1,
      'synonyms_test_unlimited' => FIELD_CARDINALITY_UNLIMITED,
    );
    foreach ($fields_map as $field_name => $cardinality) {
      $field = array(
        'field_name' => $field_name,
        'cardinality' => $cardinality,
        'locked' => TRUE,
        'type' => 'text',
      );
      field_create_field($field);

      field_create_instance(array(
        'field_name' => $field_name,
        'entity_type' => 'taxonomy_term',
        'bundle' => $bundle,
        'label' => $this->randomName(),
        'description' => $this->randomName(),
      ));
    }

    $terms = array(
      'trunk' => FALSE,
      'branch' => FALSE,
      'another_parent' => FALSE,
      'branch_child' => FALSE,
    );
    foreach ($terms as $term_type => $tmp) {
      $url = 'admin/structure/taxonomy/enabled/add';
      $name = $this->randomName();
      $edit = array(
        'name' => $name,
      );

      // Putting "branch" to be parent of "branch_child".
      if ($term_type == 'branch_child') {
        $edit['parent[]'] = array($terms['branch']->tid, $terms['another_parent']->tid);
      }

      foreach ($fields_map as $field_name => $cardinality) {
        switch ($cardinality) {
          case 1:
            $edit[$field_name . '[und][0][value]'] = $this->randomName();
            break;

          case FIELD_CARDINALITY_UNLIMITED:
            $count = rand(0, 3);
            for ($i = 0; $i < $count; $i++) {
              $edit[$field_name . '[und][' . $i . '][value]'] = $this->randomName();
              $this->drupalPost($url, $edit, 'Add another item');
              $url = NULL;
            }
            break;
        }
      }
      $this->drupalPost($url, $edit, 'Save');
      $terms[$term_type] = array_pop(taxonomy_get_term_by_name($name));
    }

    $this->drupalPost('taxonomy/term/' . $terms['branch']->tid . '/merge', array(
      'term_trunk' => $terms['trunk']->tid,
    ), 'Submit');

    $this->drupalGet('taxonomy/term/' . $terms['branch']->tid);
    $this->assertResponse(404, 'The merged term has been deleted');

    // Now making sure the fields' value has been put into the new term.
    $this->drupalGet('taxonomy/term/' . $terms['trunk']->tid);
    foreach ($fields_map as $field_name => $cardinality) {
      switch ($cardinality) {
        case 1:
          $this->assertText($terms['trunk']->{$field_name}['und'][0]['value'], 'Single Field of trunk is found.');
          $this->assertNoText($terms['branch']->{$field_name}['und'][0]['value'], 'Single Field of branch is not found.');
          break;

        case FIELD_CARDINALITY_UNLIMITED:
          foreach (array('trunk', 'branch') as $term_type) {
            $term = $terms[$term_type];
            if (!empty($term->{$field_name})) {
              foreach ($term->{$field_name}['und'] as $delta => $item) {
                $this->assertText($item['value'], 'Multiple Field of ' . $term_type . ' delta ' . $delta . ' is found.');
              }
            }
          }
          break;
      }
    }

    // And lastly we make sure that the child's parent became "trunk".
    $parents = taxonomy_get_parents($terms['branch_child']->tid);
    $intersection = array_intersect(array_keys($parents), array($terms['trunk']->tid, $terms['another_parent']->tid));
    $this->assertEqual(count($intersection), count($parents), 'The parent reference of children of the merged term has been altered to the trunk term.');
  }

  /**
   * Test all cases for potentially "buggy" input.
   *
   * Test the functionality of "term merge" feature.
   */
  public function testTermMergeResistance() {
    drupal_static_reset();
    // Trying to merge a term from a vocabulary with disabled feature
    // "term merge".
    $terms = array(
      'trunk' => FALSE,
      'branch' => FALSE,
    );

    // Making sure "term merge" is disabled.
    $this->drupalPost('admin/structure/taxonomy/disabled/edit', array(
      'synonyms[term_merge]' => FALSE,
    ), 'Save');

    foreach ($terms as $term_type => $tmp) {
      $url = 'admin/structure/taxonomy/disabled/add';
      $name = $this->randomName();
      $edit = array(
        'name' => $name,
      );

      $this->drupalPost($url, $edit, 'Save');
      $terms[$term_type] = $this->getLastTerm($this->vocabularies['disabled']);
    }

    actions_do('synonyms_term_merge_action', $terms['branch'], array('term_trunk' => $terms['trunk']->tid));
    $this->termMergeResistanceAssert($terms, 'Testing merging a term from vocabulary with disabled feature "term merge"');

    // Trying to merge 2 terms from 2 different vocabularies.
    // Temporarely enabling "term merge" feature for another vocabulary.
    $this->drupalPost('admin/structure/taxonomy/disabled/edit', array(
      'synonyms[term_merge]' => TRUE,
    ), 'Save');

    $terms = array(
      'enabled' => FALSE,
      'disabled' => FALSE,
    );

    foreach ($terms as $term_type => $tmp) {
      $url = 'admin/structure/taxonomy/' . $term_type . '/add';
      $name = $this->randomName();
      $edit = array(
        'name' => $name,
      );

      $this->drupalPost($url, $edit, 'Save');
      $terms[$term_type] = $this->getLastTerm($this->vocabularies[$term_type]);
    }

    actions_do('synonyms_term_merge_action', $terms['enabled'], array('term_trunk' => $terms['disabled']->tid));
    $this->termMergeResistanceAssert($terms, 'Testing merging 2 terms from 2 different vocabularies');

    // Disabling the feature back for another vocabulary.
    $this->drupalPost('admin/structure/taxonomy/disabled/edit', array(
      'synonyms[term_merge]' => FALSE,
    ), 'Save');

    // Trying to merge a parent into its child.
    $terms = array(
      'parent' => FALSE,
      'child' => FALSE,
    );
    drupal_static_reset();

    foreach ($terms as $term_type => $tmp) {
      $url = 'admin/structure/taxonomy/enabled/add';
      $name = $this->randomName();
      $edit = array(
        'name' => $name,
      );

      if ($term_type == 'child') {
        $edit['parent[]'] = array($terms['parent']->tid);
      }

      $this->drupalPost($url, $edit, 'Save');
      $terms[$term_type] = $this->getLastTerm($this->vocabularies['enabled']);
    }

    actions_do('synonyms_term_merge_action', $terms['parent'], array('term_trunk' => $terms['child']->tid));
    $this->termMergeResistanceAssert($terms, 'Testing merging a parent into its child');

    // Trying to merge a term into itself.
    $terms = array(
      'single' => FALSE,
    );

    foreach ($terms as $term_type => $tmp) {
      $url = 'admin/structure/taxonomy/enabled/add';
      $name = $this->randomName();
      $edit = array(
        'name' => $name,
      );

      $this->drupalPost($url, $edit, 'Save');
      $terms[$term_type] = $this->getLastTerm($this->vocabularies['enabled']);
    }

    actions_do('synonyms_term_merge_action', $terms['single'], array('term_trunk' => $terms['single']->tid));
    $this->termMergeResistanceAssert($terms, 'Testing merging a term into itself');
  }

  /**
   * Supportive function for the main test "testTermMergeResistance".
   *
   * Asserts that each term of the array $terms is available.
   *
   * @param array $terms
   *   Array of taxonomy terms objects
   * @param string $message
   *   Assertion message to be showed on the test results page
   */
  protected function termMergeResistanceAssert($terms, $message) {
    foreach ($terms as $term) {
      $this->drupalGet('taxonomy/term/' . $term->tid);
      $this->assertResponse(200, $message);
    }
  }
}

/**
 * Test "Synonym friednly autocomplete" widget of Synonyms module.
 */
class AutocompleteSynonymsWebTestCase extends SynonymsWebTestCase {
  protected $vocabularies = array(
    'enabled' => TRUE,
    'disabled' => FALSE,
  );

  protected $terms = array(
    'enabled' => array(),
    'disabled' => array(),
  );

  /**
   * GetInfo method.
   */
  public function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms autocomplete',
      'description' => 'Ensure that the "synonym friendly autocomplete" widget works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp() {
    parent::setUp();
    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    foreach ($this->vocabularies as $k => $v) {
      $name = $this->randomName();
      $this->drupalPost('admin/structure/taxonomy/add', array(
        'name' => $name,
        'machine_name' => $k,
        'description' => $this->randomName(),
        'synonyms[synonyms]' => $v,
      ), 'Save');
      $this->vocabularies[$k] = taxonomy_vocabulary_machine_name_load($k);
    }

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => 'synonyms_test_content',
    ), 'Save content type');

    // Attaching each vocabulary term reference field to the new content type.
    foreach ($this->vocabularies as $k => $v) {
      $this->drupalPost('admin/structure/types/manage/synonyms_test_content/fields', array(
        'fields[_add_new_field][label]' => 'Synonym Terms ' . $k,
        'fields[_add_new_field][field_name]' => 'synonyms_term_' . $k,
        'fields[_add_new_field][type]' => 'taxonomy_term_reference',
        'fields[_add_new_field][widget_type]' => 'synonyms_autocomplete',
      ), 'Save');
      $this->drupalPost(NULL, array(
        'field[settings][allowed_values][0][vocabulary]' => $v->machine_name,
      ), 'Save field settings');
      $this->drupalPost(NULL, array(
        'field[cardinality]' => FIELD_CARDINALITY_UNLIMITED,
      ), 'Save settings');
    }
    // Flushing static cache.
    _field_info_collate_fields(TRUE);

    // Now creating taxonomy tree for each vocabularies.
    // For synonym-disbaled vocabulary just one term is good enough.
    $name = $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/disabled/add', array(
      'name' => $name,
    ), 'Save');
    $this->terms['disabled']['term1'] = $this->getLastTerm($this->vocabularies['disabled']);
    $name .= $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/disabled/add', array(
      'name' => $name,
    ), 'Save');
    $this->terms['disabled']['term1_longer_name'] = $this->getLastTerm($this->vocabularies['disabled']);
    $this->drupalPost('admin/structure/taxonomy/disabled/add', array(
      'name' => $this->randomName(),
    ), 'Save');
    $this->terms['disabled']['term2'] = $this->getLastTerm($this->vocabularies['disabled']);

    // For synonym-enabled vocabulary we have to create such a set of input,
    // that would cover all possible branches of the autocomplete callback.
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['no_synonyms'] = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['one_synonym'] = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $this->randomName(),
    ), 'Add another item');
    $this->drupalPost(NULL, array(
      'synonyms_synonyms[und][1][value]' => $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['two_synonyms'] = $this->getLastTerm($this->vocabularies['enabled']);
    $name = $this->randomName();
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $name,
      'synonyms_synonyms[und][0][value]' => $name . $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['name_similar_synonym'] = $this->getLastTerm($this->vocabularies['enabled']);
    $name = 'simiar_synonyms_';
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $name . $this->randomName(),
    ), 'Add another item');
    $this->drupalPost(NULL, array(
      'synonyms_synonyms[und][1][value]' => $name . $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['similar_synonyms'] = $this->getLastTerm($this->vocabularies['enabled']);
    $name = 'one_term_name_another_synonym_';
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $name . $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['name_another_synonym'] = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $name . $this->randomName(),
    ), 'Save');
    $this->terms['enabled']['synonym_another_name'] = $this->getLastTerm($this->vocabularies['enabled']);
  }

  /**
   * Test auto-creation functionality.
   *
   * Test the auto-creation funcationality of the synonym friendly autocomplete
   * widget type.
   */
  public function testAutoCreation() {
    // Trying enabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/field_synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => TRUE,
    ), 'Save settings');

    $new_term_name = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'field_synonyms_term_enabled[und]' => $this->terms['enabled']['no_synonyms']->name . ', ' . $new_term_name,
    ), 'Save');
    $this->assertText($this->terms['enabled']['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertText($new_term_name, 'Auto created term was assigned to the new node');
    $term = $this->getLastTerm($this->vocabularies['enabled']);
    $this->assertEqual($term->name, $new_term_name, 'The auto created term has been created');

    // Trying disabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/field_synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => FALSE,
    ), 'Save settings');

    $new_term_name = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'field_synonyms_term_enabled[und]' => $this->terms['enabled']['no_synonyms']->name . ', ' . $new_term_name,
    ), 'Save');
    $this->assertText($this->terms['enabled']['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertNoText($new_term_name, 'Auto created term was not assigned to the new node');
    $term = $this->getLastTerm($this->vocabularies['enabled']);
    $this->assertNotEqual($term->name, $new_term_name, 'The auto created term has not been created');
  }

  /**
   * Test autocomplete menu path.
   *
   * Feed all known "buggy" input to synonym friendly autocomplete menu path,
   * in order to test its performance.
   */
  public function testAutocompleteMenuPath() {
    $assertions = array();
    // Testing empty and non-existing name arguments.
    foreach ($this->vocabularies as $v) {
      $assertions[] = array(
        'vocabulary' => $v->machine_name,
        'input' => '',
        'response' => array(),
        'message' => 'Submitting empty string into a ' . $v->machine_name . ' synonyms vocabulary',
      );
      $assertions[] = array(
        'vocabulary' => $v->machine_name,
        'input' => $this->randomName(),
        'response' => array(),
        'message' => 'Submitting non existing name into a ' . $v->machine_name . ' synonyms vocabulary',
      );
    }

    // Testing the synonym-disabled vocabulary.
    $terms = $this->terms['disabled'];
    $assertions[] = array(
      'vocabulary' => 'disabled',
      'input' => drupal_strtoupper(drupal_substr($terms['term1']->name, 1, -1)),
      'response' => array($terms['term1']->name => $terms['term1']->name, $terms['term1_longer_name']->name => $terms['term1_longer_name']->name),
      'message' => 'Submitting a name similar to 2 existing term names into a disabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'disabled',
      'input' => $terms['term1']->name . ',' . drupal_strtoupper(drupal_substr($terms['term1']->name, 1, -1)),
      'response' => array($terms['term1']->name . ', ' . $this->terms['disabled']['term1_longer_name']->name => $this->terms['disabled']['term1_longer_name']->name),
      'message' => 'Submitting one term already chosen along with a name similar to 2 existing term names into a disabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'disabled',
      'input' => drupal_strtoupper(drupal_substr($terms['term2']->name, 1, -1)),
      'response' => array($terms['term2']->name => $terms['term2']->name),
      'message' => 'Submitting a name similar to one existing term name into a disabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'disabled',
      'input' => drupal_strtolower($terms['term2']->name) . ',' . drupal_strtoupper(drupal_substr($terms['term2']->name, 1, -1)),
      'response' => array(),
      'message' => 'Submitting the same term over again into a disabled synonyms vocabulary',
    );

    // Testing the synonym-enabled vocabulary.
    $terms = $this->terms['enabled'];
    $assertions[] = array(
      'vocabulary' => 'enabled',
      'input' => drupal_strtoupper($terms['no_synonyms']->name) . ',' . drupal_strtolower(drupal_substr($terms['no_synonyms']->name, 1, -1)),
      'response' => array(),
      'message' => 'Submitting the same term over again into an enabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'enabled',
      'input' => $terms['one_synonym']->name . ',' . $terms['one_synonym']->synonyms_synonyms[LANGUAGE_NONE][0]['safe_value'],
      'response' => array(),
      'message' => 'Submitting a synonym of a term over again into an enabled synonyms vocabulary',
    );
    foreach (array('no_synonyms', 'one_synonym', 'two_synonyms') as $k) {
      $assertions[] = array(
        'vocabulary' => 'enabled',
        'input' => drupal_strtolower(drupal_substr($terms[$k]->name, 1, -1)),
        'response' => array($terms[$k]->name => $terms[$k]->name),
        'message' => 'Submitting a name similar to ' . $k . ' term into an enabled synonyms vocabulary',
      );

      $synonyms = field_get_items('taxonomy_term', $terms[$k], 'synonyms_synonyms');
      if (is_array($synonyms)) {
        foreach ($synonyms as $delta => $item) {
          $assertions[] = array(
            'vocabulary' => 'enabled',
            'input' => drupal_strtolower(drupal_substr($item['safe_value'], 1, -1)),
            'response' => array($terms[$k]->name => $this->synonymAutocompleteResult($terms[$k], $item['safe_value'])),
            'message' => 'Submitting a name similar to synonym#' . $delta . ' of the term ' . $k . 'into an enabled synonyms vocabulary',
          );
        }
      }
    }
    $assertions[] = array(
      'vocabulary' => 'enabled',
      'input' => $terms['name_similar_synonym']->name,
      'response' => array($terms['name_similar_synonym']->name => $terms['name_similar_synonym']->name),
      'message' => 'Submitting a keyword similar to name and synonym of a term into an enabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'enabled',
      'input' => 'simiar_synonyms_',
      'response' => array($terms['similar_synonyms']->name => $this->synonymAutocompleteResult($terms['similar_synonyms'], $terms['similar_synonyms']->synonyms_synonyms[LANGUAGE_NONE][0]['safe_value'])),
      'message' => 'Submitting a keyword similar to name and synonym of a term into an enabled synonyms vocabulary',
    );
    $assertions[] = array(
      'vocabulary' => 'enabled',
      'input' => 'one_term_name_another_synonym_',
      'response' => array($terms['name_another_synonym']->name => $terms['name_another_synonym']->name, $terms['synonym_another_name']->name => $this->synonymAutocompleteResult($terms['synonym_another_name'], $terms['synonym_another_name']->synonyms_synonyms[LANGUAGE_NONE][0]['safe_value'])),
      'message' => 'Submitting a keyword similar to name of one term and synonym of another into an enabled synonyms vocabulary yields both included in the results',
    );

    foreach ($assertions as $v) {
      $this->assertAutocompleteMenuPath($v);
    }
  }

  /**
   * Assert output of synonym friendly autocomplete path.
   *
   * @param array $assertion
   *   Specially encoded array of assertion. Should include the follwing keys:
   *     vocabulary - machine name of vocabulary whose field is asserted
   *     input - input string to be fed to autocomplete menu path
   *     response - JSON decoded expected response of autocomplete menu path
   *     message - Drupal assertion message to be displayed on test results 
   *                 page 
   */
  protected function assertAutocompleteMenuPath($assertion) {
    $response = $this->drupalGet('synonyms/autocomplete/field_synonyms_term_' . $assertion['vocabulary'] . '/' . $assertion['input']);
    if (!$response) {
      $this->fail($assertion['message'], 'Autocomplete Menu Path');
      return;
    }
    $response = (array) json_decode($response);
    $is_the_same = count($response) == count($assertion['response']);
    $is_the_same = $is_the_same && count(array_intersect_assoc($response, $assertion['response'])) == count($assertion['response']);

    $this->assertTrue($is_the_same, $assertion['message'], 'Autocomplete Menu Path');
  }

  /**
   * Return expected autocomplete menu path result.
   *
   * The result is prepared as if the term was found by the supplied synonym.
   *
   * @param object $term
   *   Fully loaded taxonomy term object for which the result is generated.
   * @param string $synonym
   *   Synonym by which the term was hit in the search
   * @return string
   *   Formatted autocomplete result
   */
  protected function synonymAutocompleteResult($term, $synonym) {
    return t('@synonym, synonym of %term', array('@synonym' => $synonym, '%term' => $term->name));
  }
}

/**
 * Test Synonyms module integration with Drupal search functionality.
 */
class SearchIndexSynonymsWebTestCase extends SynonymsWebTestCase {
  protected $vocabularies = array(
    'enabled' => TRUE,
  );

  /**
   * GetInfo method.
   */
  public function getInfo() {
    return array(
      'name' => 'Synonyms search integration',
      'description' => 'Ensure that Synonyms module correctly integrates with the Drupal search functionality.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp() {
    parent::setUp();
    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    foreach ($this->vocabularies as $k => $v) {
      $name = $this->randomName();
      $this->drupalPost('admin/structure/taxonomy/add', array(
        'name' => $name,
        'machine_name' => $k,
        'description' => $this->randomName(),
        'synonyms[synonyms]' => $v,
      ), 'Save');
      $this->vocabularies[$k] = taxonomy_vocabulary_machine_name_load($k);
    }

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => 'synonyms_test_content',
    ), 'Save content type');

    // Attaching each vocabulary term reference field to the new content type.
    foreach ($this->vocabularies as $k => $v) {
      $this->drupalPost('admin/structure/types/manage/synonyms_test_content/fields', array(
        'fields[_add_new_field][label]' => 'Synonym Terms ' . $k,
        'fields[_add_new_field][field_name]' => 'synonyms_term_' . $k,
        'fields[_add_new_field][type]' => 'taxonomy_term_reference',
        'fields[_add_new_field][widget_type]' => 'synonyms_autocomplete',
      ), 'Save');
      $this->drupalPost(NULL, array(
        'field[settings][allowed_values][0][vocabulary]' => $v->machine_name,
      ), 'Save field settings');
      $this->drupalPost(NULL, array(
        'field[cardinality]' => FIELD_CARDINALITY_UNLIMITED,
      ), 'Save settings');
    }
    // Flushing static cache.
    _field_info_collate_fields(TRUE);
  }

  /**
   * Test searching by a term synonym.
   *
   * Since logically term and its synonyms represent the same entity, the idea
   * is that searching by a term synonym should trigger all content referencing
   * that term to be included in search results.
   */
  public function testSearchTermSynonym() {
    // Create a few terms and synonyms
    $terms = array();
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
    ), 'Save');
    $terms['no_synonyms'] = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $this->randomName(),
    ), 'Save');
    $terms['one_synonym'] = $this->getLastTerm($this->vocabularies['enabled']);
    $this->drupalPost('admin/structure/taxonomy/enabled/add', array(
      'name' => $this->randomName(),
      'synonyms_synonyms[und][0][value]' => $this->randomName(),
    ), 'Add another item');
    $this->drupalPost(NULL, array(
      'synonyms_synonyms[und][1][value]' => $this->randomName(),
    ), 'Save');
    $terms['two_synonyms'] = $this->getLastTerm($this->vocabularies['enabled']);

    $assertions = array();

    // Creating a node, which refereces to all the terms we have.
    $title = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $title,
      'field_synonyms_term_enabled[und]' => $terms['no_synonyms']->name . ', ' . $terms['one_synonym']->name . ', ' . $terms['two_synonyms']->name,
    ), 'Save');
    $node = $this->drupalGetNodeByTitle($title);

    // Rebuilding Search index.
    $this->cronRun();

    foreach ($terms as $k => $v) {
      $assertions[] = array(
        'keyword' => $v->name,
        'results' => array($node),
        'message' => 'Searching by name of the term ' . $k,
      );
      foreach (synonyms_get_term_synonyms($v) as $delta => $synonym) {
        $assertions[] = array(
          'keyword' => $synonym['value'],
          'results' => array($node),
          'message' => 'Searching by synonym #' . $delta . ' of the term ' . $k,
        );
      }
    }

    foreach ($assertions as $assertion) {
      $this->assertSearchResults($assertion);
    }
  }

  /**
   * Assert search results.
   *
   * @param array $assertion
   *   Specially encoded array of assertion. Should include the follwing keys:
   *     keyword - what keyword has to be supplied to the search mechanism
   *     results - array of nodes that are expected to be on search results
   *     message - Drupal assertion message to be displayed on test results 
   *                 page 
   */
  protected function assertSearchResults($assertion) {
    $response = $this->drupalGet('search/node/' . $assertion['keyword']);
    $matches = array();
    preg_match_all('#\<li[^>]+class="search-result"[^>]*\>(.*?)\</li\>#si', $response, $matches);
    $results = $matches[1];
    if (count($results) != count($assertion['results'])) {
      $this->fail($assertion['message']);
      return;
    }
    $results = implode('', $results);
    foreach ($assertion['results'] as $node) {
      if (strpos($results, 'node/' . $node->nid) === FALSE) {
        $this->fail($assertion['message']);
        return;
      }
    }
    $this->pass($assertion['message']);
  }
}
