<?php

/**
 * @file
 * Provide synonyms feature for Drupal entities.
 */

/**
 * Implements hook_menu().
 */
function synonyms_menu() {
  $items = array();

  $items['admin/structure/synonyms'] = array(
    'title' => 'Synonyms',
    'description' => 'Manage synonyms settings for all entity types.',
    'page callback' => 'synonyms_settings_overview',
    'access arguments' => array('administer synonyms'),
    'file' => 'synonyms.pages.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/structure/synonyms/%synonyms_entity_type/%synonyms_bundle'] = array(
    'title' => 'Synonyms settings',
    'title callback' => 'synonyms_settings_title',
    'title arguments' => array(3, 4),
    'description' => 'Manage synonyms settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('synonyms_settings_form', 3, 4),
    'access arguments' => array('administer synonyms'),
    'load arguments' => array(3),
    'file' => 'synonyms.pages.inc',
  );

  if (module_exists('taxonomy')) {
    $items['synonyms/autocomplete-taxonomy-term/%/%/%'] = array(
      'title' => 'Autocomplete Synonyms',
      'page callback' => 'synonyms_autocomplete_taxonomy_term',
      'page arguments' => array(2, 3, 4),
      'access arguments' => array('access content'),
      'file' => 'synonyms.pages.inc',
      'type' => MENU_CALLBACK,
    );
  }

  $items['synonyms/autocomplete-entity/%/%/%'] = array(
    'title' => 'Autocomplete Synonyms',
    'page callback' => 'synonyms_autocomplete_entity',
    'page arguments' => array(2, 3, 4),
    'access callback' => 'entityreference_autocomplete_access_callback',
    'access arguments' => array('tags', 2, 3, 4),
    'file' => 'synonyms.pages.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function synonyms_permission() {
  return array(
    'administer synonyms' => array(
      'title' => t('Administer synonyms'),
      'description' => t('Administer synonyms of all entity types.'),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_type().
 */
function synonyms_ctools_plugin_type() {
  $plugins = array();

  $plugins['behavior'] = array(
    'defaults' => array(
      'title' => NULL,
      'description' => NULL,
      'settings form callback' => NULL,
      'interface' => NULL,
      'enabled callback' => NULL,
      'disabled callback' => NULL,
    ),
  );

  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function synonyms_ctools_plugin_directory($owner, $plugin_type) {
  switch ($owner) {
    case 'synonyms':
      switch ($plugin_type) {
        case 'behavior':
          return 'plugins/' . $plugin_type;
      }
      break;

    case 'ctools':
      switch ($plugin_type) {
        case 'arguments':
          return 'plugins/' . $plugin_type;
      }
      break;
  }
}

/**
 * Implements hook_theme().
 */
function synonyms_theme() {
  return array(
    'synonyms_behaviors_settings' => array(
      'render element' => 'element',
      'file' => 'synonyms.pages.inc',
    ),
  );
}

/**
 * Implements hook_entity_property_info().
 */
function synonyms_entity_property_info() {
  $info = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $entity_type = synonyms_entity_type_load($entity_type);
    if ($entity_type) {
      $info[$entity_type]['properties']['synonyms'] = array(
        'label' => t('Synonyms'),
        'description' => t('Synonyms of entity.'),
        'type' => 'list<text>',
        'getter callback' => 'synonyms_get_sanitized',
        'computed' => TRUE,
        'sanitized' => TRUE,
        'raw getter callback' => 'synonyms_get_raw',
      );
    }
  }

  return $info;
}

/**
 * Implements hook_field_delete_instance().
 */
function synonyms_field_delete_instance($instance) {
  // Remove, if necessary, any synonyms behaviors enabled on this instance.
  $result = db_select('synonyms_settings', 's')
    ->fields('s', array('behavior'))
    ->condition('s.instance_id', $instance['id'])
    ->execute();
  foreach ($result as $row) {
    synonyms_behavior_settings_delete($instance['id'], $row->behavior);
  }
}

/**
 * Implements hook_synonyms_behavior_implementation_info().
 */
function synonyms_synonyms_behavior_implementation_info($behavior) {
  switch ($behavior) {
    case 'autocomplete':
    case 'select':
      return array(
        'number_integer' => 'TextSynonymsBehavior',
        'number_decimal' => 'TextSynonymsBehavior',
        'number_float' => 'TextSynonymsBehavior',
        'text' => 'TextSynonymsBehavior',
        'taxonomy_term_reference' => 'TaxonomySynonymsBehavior',
        'entityreference' => 'EntityReferenceSynonymsBehavior',
      );
      break;
  }
  return array();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function synonyms_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  // TODO: remove this function after a few releases of Synonyms module, since
  // now the module oversees synonyms of all entities, not only taxonomy terms.
  if (isset($form_state['confirm_delete']) && $form_state['confirm_delete']) {
    return;
  }

  if (!isset($form['#vocabulary']->vid) || !$form['#vocabulary']->vid) {
    return;
  }

  $form['synonyms'] = array(
    '#type' => 'fieldset',
    '#title' => t('Synonyms'),
    '#collapsible' => TRUE,
  );

  $form['synonyms']['link'] = array(
    '#markup' => t('You can configure synonyms of @vocabulary following <a href="@url">this link</a>.', array(
      '@vocabulary' => $form['#vocabulary']->name,
      '@url' => url('admin/structure/synonyms/taxonomy_term/' . $form['#vocabulary']->machine_name, array('query' => drupal_get_destination())),
    )),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function synonyms_field_widget_info() {
  return array(
    'synonyms_autocomplete_taxonomy_term' => array(
      'label' => t('Synonyms friendly autocomplete'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'size' => 60,
        'synonyms_autocomplete_path' => 'synonyms/autocomplete-taxonomy-term',
        'suggestion_size' => 10,
        'suggest_only_unique' => FALSE,
        'auto_creation' => 1,
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
    'synonyms_autocomplete_entity' => array(
      'label' => t('Synonyms friendly autocomplete'),
      'field types' => array('entityreference'),
      'settings' => array(
        'size' => 60,
        'synonyms_autocomplete_path' => 'synonyms/autocomplete-entity',
        'suggestion_size' => 10,
        'suggest_only_unique' => FALSE,
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
    'synonyms_select_taxonomy_term' => array(
      'label' => t('Synonyms friendly select list'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'sort' => 'weight',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
    'synonyms_select_entity' => array(
      'label' => t('Synonyms friendly select list'),
      'field types' => array('entityreference'),
      'settings' => array(),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function synonyms_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'] + field_info_widget_settings($widget['type']);

  $form = array();

  switch  ($widget['type']) {
    case 'synonyms_autocomplete_taxonomy_term':
    case 'synonyms_autocomplete_entity':
      if ($widget['type'] == 'synonyms_autocomplete_taxonomy_term') {
        $form['auto_creation'] = array(
          '#type' => 'checkbox',
          '#title' => t('Allow auto-creation?'),
          '#description' => t('Whether users may create a new term by typing in a non-existing name into this field.'),
          '#default_value' => $settings['auto_creation'],
        );
      }

      $form['suggestion_size'] = array(
        '#type' => 'textfield',
        '#title' => t('Suggestions Size'),
        '#description' => t('Please, enter how many suggested entities to show in the autocomplete textfield.'),
        '#required' => TRUE,
        '#element_validate' => array('element_validate_integer_positive'),
        '#default_value' => $settings['suggestion_size'],
      );

      $form['suggest_only_unique'] = array(
        '#type' => 'checkbox',
        '#title' => t('Suggest only one entry per term'),
        '#description' => t('If you want to include only term name or a single synonym, suggesting a particular term, while disregarding all ongoing ones, please, tick this checkbox on.'),
        '#default_value' => $settings['suggest_only_unique'],
      );
      break;

    case 'synonyms_select_taxonomy_term':
      $form['sort'] = array(
        '#type' => 'radios',
        '#title' => t('Sort'),
        '#description' => t('Choose by what criterion the items within select should be sorted.'),
        '#options' => array(
          'weight' => t('As in taxonomy vocabulary (by weight)'),
          'name' => t('By name of terms and their synonyms'),
        ),
        '#default_value' => $settings['sort'],
      );
      break;
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function synonyms_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $default_value = array();
  $column = array_keys($field['columns']);
  $column = reset($column);
  foreach ($items as $item) {
    $default_value[] = $item[$column];
  }

  switch ($instance['widget']['type']) {
    case 'synonyms_autocomplete_taxonomy_term':
    case 'synonyms_autocomplete_entity':
      switch ($instance['widget']['type']) {
        case 'synonyms_autocomplete_taxonomy_term':
          $default_value_string = taxonomy_implode_tags(taxonomy_term_load_multiple($default_value));
          $element_validate = array('taxonomy_autocomplete_validate', 'synonyms_autocomplete_taxonomy_term_validate');
          break;

        case 'synonyms_autocomplete_entity':
          $default_value_string = array();
          $entity = isset($element['#entity']) ? $element['#entity'] : NULL;
          $handler = entityreference_get_selection_handler($field, $instance, $instance['entity_type'], $entity);

          $target_entities = entity_load($field['settings']['target_type'], $default_value);
          foreach ($target_entities as $target_entity_id => $target_entity) {
            $default_value_string[] = synonyms_autocomplete_escape($handler->getLabel($target_entity));
          }
          $default_value_string = implode(', ', $default_value_string);

          $element_validate = array('synonyms_autocomplete_entity_validate');
          break;
      }

      $element += array(
        '#type' => 'textfield',
        '#default_value' => $default_value_string,
        '#autocomplete_path' => $instance['widget']['settings']['synonyms_autocomplete_path'] . '/' . $field['field_name'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'],
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => 1024,
        '#element_validate' => $element_validate,
        '#attached' => array(
          'js' => array(
            drupal_get_path('module', 'synonyms') . '/js/synonyms-autocomplete.js' => array(),
          ),
        ),
        '#attributes' => array(
          'class' => array('synonyms-autocomplete'),
        ),
      );
      if (isset($instance['widget']['settings']['auto_creation'])) {
        $element['#auto_creation'] = $instance['widget']['settings']['auto_creation'];
      }
      break;

    case 'synonyms_select_taxonomy_term':
      $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;

      $options = array();
      foreach ($field['settings']['allowed_values'] as $tree) {
        if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
          switch ($instance['widget']['settings']['sort']) {
            case 'weight':
              if ($terms = taxonomy_get_tree($vocabulary->vid, $tree['parent'], NULL, TRUE)) {
                $behavior_implementations = synonyms_behavior_get('select', 'taxonomy_term', field_extract_bundle('taxonomy_term', $vocabulary), TRUE);
                foreach ($terms as $term) {
                  $options[] = synonyms_select_option_entity($term, 'taxonomy_term', NULL, NULL, array('depth'));
                  foreach ($behavior_implementations as $implementation) {
                    foreach (synonyms_extract_synonyms($term, $implementation) as $synonym) {
                      $options[] = synonyms_select_option_entity($term, 'taxonomy_term', $synonym, $implementation, array('depth'));
                    }
                  }
                }
              }
              break;

            case 'name':
              // TODO: is there any way to leverage DB for the sorting routine?
              $options = synonyms_select_taxonomy_term_sort_name_options_recursive($vocabulary, $tree['parent']);
              break;
          }
        }
      }

      $element += array(
        '#type' => 'select',
        '#multiple' => $multiple,
        '#options' => $options,
        '#default_value' => $default_value,
        '#element_validate' => array('synonyms_select_form_to_storage'),
        '#empty_option' => t('- None -'),
      );
      break;

    case 'synonyms_select_entity':
      $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;

      $options = entityreference_get_selection_handler($field, $instance, $instance['entity_type'], $element['#entity'])->getReferencableEntities();
      $synonyms_options = array();

      $target_entity_info = entity_get_info($field['settings']['target_type']);
      $entity_ids = array();
      foreach ($options as $bundle_entity_ids) {
        $entity_ids = array_merge($entity_ids, array_keys($bundle_entity_ids));
      }
      $entities = entity_load($field['settings']['target_type'], $entity_ids);
      foreach ($options as $bundle => $bundle_entity_ids) {
        $synonyms_options[$target_entity_info['bundles'][$bundle]['label']] = array();

        $behavior_implementations = synonyms_behavior_get('select', $field['settings']['target_type'], $bundle, TRUE);

        foreach ($bundle_entity_ids as $entity_id => $v) {
          $entity = $entities[$entity_id];
          $synonyms_options[$target_entity_info['bundles'][$bundle]['label']][] = synonyms_select_option_entity($entity, $field['settings']['target_type']);
          foreach ($behavior_implementations as $behavior_implementation) {
            foreach (synonyms_extract_synonyms($entity, $behavior_implementation) as $synonym) {
              $synonyms_options[$target_entity_info['bundles'][$bundle]['label']][] = synonyms_select_option_entity($entity, $field['settings']['target_type'], $synonym, $behavior_implementation);
            }
          }
        }
        usort($synonyms_options[$target_entity_info['bundles'][$bundle]['label']], 'synonyms_select_sort_name');
      }

      if (count($synonyms_options) == 1) {
        $synonyms_options = reset($synonyms_options);
      }

      $element += array(
        '#type' => 'select',
        '#multiple' => $multiple,
        '#options' => $synonyms_options,
        '#default_value' => $default_value,
        '#element_validate' => array('synonyms_select_form_to_storage'),
        '#empty_option' => t('- None -'),
      );
      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function synonyms_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Implements hook_features_api().
 */
function synonyms_features_api() {
  return array(
    'synonyms' => array(
      'name' => t('Synonyms'),
      'file' => drupal_get_path('module', 'synonyms') . '/synonyms.features.inc',
      'default_hook' => 'default_synonyms',
      'feature_source' => TRUE,
    ),
  );
}

/**
 * Form element validate handler.
 *
 * Handle validation for taxonomy term synonym-friendly autocomplete element.
 */
function synonyms_autocomplete_taxonomy_term_validate($element, &$form_state) {
  // After taxonomy_autocomplete_validate() has finished its job any terms it
  // didn't find have been set for autocreation. We need to:
  // (a) Double-check that those terms are not synonyms.
  // (b) Check that synonyms' configurable auto-creation option is enabled.
  $value = drupal_array_get_nested_value($form_state['values'], $element['#parents']);

  $tids = array();

  $field = field_widget_field($element, $form_state);
  foreach ($value as $delta => $term) {
    if ($term['tid'] == 'autocreate') {
      $synonym_tid = 0;
      foreach ($field['settings']['allowed_values'] as $tree) {
        $behavior_implementations = synonyms_behavior_get('autocomplete', 'taxonomy_term', $tree['vocabulary'], TRUE);
        foreach ($behavior_implementations as $behavior_implementation) {
          $synonyms = synonyms_synonyms_find_behavior(db_and()->condition(AbstractSynonymsBehavior::COLUMN_PLACEHOLDER, $term['name']), $behavior_implementation);
          foreach ($synonyms as $synonym) {
            $synonym_tid = $synonym->entity_id;
            break(2);
          }
        }
      }

      if ($synonym_tid != 0 && !in_array($synonym_tid, $tids)) {
        $value[$delta]['tid'] = $synonym_tid;
        $tids[] = $synonym_tid;
      }
      elseif (!$element['#auto_creation']) {
        unset($value[$delta]);
      }
    }
    else {
      $tids[] = $term['tid'];
    }
  }
  $value = array_values($value);
  form_set_value($element, $value, $form_state);
}

/**
 * Form element validate handler.
 *
 * Validate entity reference synonyms friendly autocomplete element.
 */
function synonyms_autocomplete_entity_validate($element, &$form_state) {
  $input = drupal_map_assoc(drupal_explode_tags(drupal_strtolower($element['#value'])));

  $value = array();
  if (!empty($input)) {
    $field = field_info_field($element['#field_name']);
    $instance = field_info_instance($element['#entity_type'], $field['field_name'], $element['#bundle']);
    $handler = entityreference_get_selection_handler($field, $instance);
    $matches = $handler->getReferencableEntities($input, 'IN');

    foreach ($matches as $bundle => $entity_ids) {
      foreach ($entity_ids as $entity_id => $label) {
        $value[] = $entity_id;
        unset($input[drupal_strtolower($label)]);
      }
    }

    if (!empty($input)) {
      $behavior_implementations = synonyms_behavior_get('autocomplete', $field['settings']['target_type'], synonyms_field_target_bundles($field), TRUE);
      foreach ($behavior_implementations as $implementation) {
        $condition = db_and();
        $condition->condition(AbstractSynonymsBehavior::COLUMN_PLACEHOLDER, $input, 'IN');
        foreach (synonyms_synonyms_find_behavior($condition, $implementation) as $synonym) {
          unset($input[drupal_strtolower($synonym->synonym)]);
          $value[] = $synonym->entity_id;
        }
      }
    }
  }

  $tmp = array_unique($value);
  $value = array();
  foreach ($tmp as $target_id) {
    $value[] = array('target_id' => $target_id);
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Try finding an entity by its name or synonym.
 *
 * @param string $entity_type
 *   What entity type is being searched
 * @param string $name
 *   The look up keyword (the supposed name or synonym)
 * @param string $bundle
 *   Optionally limit the search within a specific bundle name of the provided
 *   entity type
 *
 * @return int
 *   ID of the looked up entity. If such entity was not found, then 0 is
 *   returned
 */
function synonyms_get_entity_by_synonym($entity_type, $name, $bundle = NULL) {
  $name = trim($name);
  $entity_info = entity_get_info($entity_type);
  if (isset($entity_info['entity keys']['label'])) {
    $efq = new EntityFieldQuery();
    $efq->entityCondition('entity_type', $entity_type);
    if ($bundle) {
      $efq->entityCondition('bundle', $bundle);
    }
    $efq->propertyCondition($entity_info['entity keys']['label'], $name);
    $result = $efq->execute();
    if (isset($result[$entity_type])) {
      $result = array_keys($result[$entity_type]);
      return reset($result);
    }
  }

  $synonyms = synonyms_synonyms_find(db_and()->condition(AbstractSynonymsBehavior::COLUMN_PLACEHOLDER, $name), $entity_type, $bundle);
  if (!empty($synonyms)) {
    return reset($synonyms)->entity_id;
  }
  return 0;
}

/**
 * Try to find a term by its name or synonym.
 *
 * You are advised to use the more general function
 * synonyms_get_entity_by_synonym() unless you really need $parent input
 * argument from this function for additional filtering by Taxonomy hierarchy.
 *
 * @param string $name
 *   The string to be searched for its {taxonomy_term_data}.tid
 * @param object $vocabulary
 *   Fully loaded vocabulary object in which you wish to search
 * @param int $parent
 *   Optional. In case you want to narrow your search scope, this parameter
 *   takes in the {taxonomy_term_data}.tid of the parent term, letting you
 *   search only among its children
 *
 * @return int
 *   If the look up was successful returns the {taxonomy_term_data}.tid of the
 *   found term, otherwise returns 0
 */
function synonyms_get_term_by_synonym($name, $vocabulary, $parent = 0) {
  if (!module_exists('taxonomy')) {
    return 0;
  }
  $name = trim($name);

  $terms = taxonomy_get_term_by_name($name, $vocabulary->machine_name);
  foreach ($terms as $term) {
    if (!$parent || synonyms_taxonomy_term_is_child_of($term->tid, $parent)) {
      // TODO: actually it could be so that there is more than 1 term that
      // satisfies the search query, i.e. the name and parent constraints. At
      // the moment we are going to return the first one we encounter, though
      // something better could be thought of in the future.
      return $term->tid;
    }
  }

  // We have failed to find a term with the provided $name. So let's search now
  // among the term synonyms.
  $bundle = field_extract_bundle('taxonomy_term', $vocabulary);
  $synonyms = synonyms_synonyms_find(db_and()->condition(AbstractSynonymsBehavior::COLUMN_PLACEHOLDER, $name), 'taxonomy_term', $bundle);
  foreach ($synonyms as $synonym) {
    if (!$parent || synonyms_taxonomy_term_is_child_of($synonym->entity_id, $parent)) {
      // TODO: similarly here, as above, we could have more than 1 match, but
      // for now we will simply return the first one encountered.
      return $synonym->entity_id;
    }
  }

  // If we have reached down here, this means we haven't got any match
  // as fallback we return 0.
  return 0;
}

/**
 * Look up a term considering synonyms and if nothing is found add one.
 *
 * This function is useful for automated creation of new terms as it won't
 * generate the same terms over and over again.
 *
 * @param string $name
 *   The string to be searched for its {taxonomy_term_data}.tid
 * @param object $vocabulary
 *   Fully loaded vocabulary object in which you wish to search
 * @param int $parent
 *   Optional. In case you want to narrow your search scope, this parameter
 *   takes in the {taxonomy_term_data}.tid of the parent term, letting you
 *   search only among its children
 *
 * @return int
 *   If a term already exists, its {taxonomy_term_data}.tid is returned,
 *   otherwise it creates a new term and returns its {taxonomy_term_data}.tid
 */
function synonyms_add_term_by_synonym($name, $vocabulary, $parent = 0) {
  if (!module_exists('taxonomy')) {
    return 0;
  }
  $tid = synonyms_get_term_by_synonym($name, $vocabulary, $parent);
  if ($tid) {
    // We found some term, returning its tid.
    return $tid;
  }

  // We haven't found any term, so we create one.
  $term = (object) array(
    'name' => $name,
    'vid' => $vocabulary->vid,
    'parent' => array($parent),
  );
  taxonomy_term_save($term);

  if (isset($term->tid)) {
    return $term->tid;
  }

  // Normally we shouldn't reach up to here, because a term would have got
  // created and the just created tid would have been returned. Nevertheless,
  // as a fallback in case of any error we return 0.
  return 0;
}

/**
 * Retrieve list of sanitized synonyms of an entity.
 *
 * @param $entity object
 *   Fully loaded entity
 *
 * @return array
 *   List of sanitized synonyms of an entity
 */
function synonyms_get_sanitized($entity, array $options, $name, $entity_type, &$context) {
  return array_map('check_plain', synonyms_get_raw($entity, $options, $name, $entity_type, $context));
}

/**
 * Retrieve list of raw synonyms of an entity.
 *
 * @param $entity object
 *   Fully loaded entity
 *
 * @return array
 *   List of raw synonyms of an entity
 */
function synonyms_get_raw($entity, array $options, $name, $entity_type, &$context) {
  $synonyms = array();
  $bundle = entity_extract_ids($entity_type, $entity);
  $bundle = $bundle[2];

  $behavior_implementations = synonyms_behavior_get_all_enabled($entity_type, $bundle);
  $instance_ids = array();
  foreach ($behavior_implementations as $implementation) {
    if (!in_array($implementation['instance_id'], $instance_ids)) {
      $synonyms = array_merge($synonyms, synonyms_extract_synonyms($entity, $implementation));
      $instance_ids[] = $implementation['instance_id'];
    }
  }
  return $synonyms;
}

/**
 * Public function for retrieving synonyms of a taxonomy term.
 *
 * You are encouraged to use synonyms_get_sanitized() or synonyms_get_raw()
 * instead. This function soon will be removed from the source code.
 *
 * @param object $term
 *   Fully loaded taxonomy term for which the synonyms are desired
 *
 * @return array
 *   Array of synonyms, if synonyms are disabled for the taxonomy term's
 *   vocabulary, an empty array is returned. Each synonym subarray consists of
 *   the following keys:
 *   - value: (string) the value of a synonym as it was input by user
 *   - safe_value: (string) a sanitized value of a synonym
 *
 * @deprecated
 */
function synonyms_get_term_synonyms($term) {
  if (!module_exists('taxonomy')) {
    return array();
  }
  $synonyms = array();
  $vocabulary = taxonomy_vocabulary_load($term->vid);
  $bundle = field_extract_bundle('taxonomy_term', $vocabulary);

  $behavior_implementations = synonyms_behavior_get_all_enabled('taxonomy_term', $bundle);
  foreach ($behavior_implementations as $implementation) {
    foreach  (synonyms_extract_synonyms($term, $implementation) as $synonym) {
      $synonyms[] = array(
        'value' => $synonym,
        'safe_value' => check_plain($synonym),
      );
    }
  }

  return $synonyms;
}

/**
 * Extract synonyms of an entity within a certain field and behavior.
 *
 * Do not use this function, if you want to get synonyms of an entity, unless
 * you know what you are doing. This function extracts the synonyms only from a
 * specific field. If you simply want "get me all the synonyms of this entity"
 * kind of function, use synonyms_get_sanitized() and/or
 * synonyms_get_sanitized().
 *
 * @param object $entity
 *   Fully loaded entity, synonyms from which should be extracted
 * @param array  $behavior_implementation
 *   Fully loaded behavior implementation. Supply here one of the values from
 *   the return of synonyms_behavior_get() function
 *
 * @return array
 *   Array of synonyms that reside in the field dictated by
 *   $behavior_implementation parameter
 */
function synonyms_extract_synonyms($entity, $behavior_implementation) {
  $synonyms = array();
  $field = field_info_field($behavior_implementation['field_name']);
  $instance = field_info_instance($behavior_implementation['entity_type'], $behavior_implementation['field_name'], $behavior_implementation['bundle']);
  $items = field_get_items($behavior_implementation['entity_type'], $entity, $field['field_name']);

  if (is_array($items) && !empty($items)) {
    $object = synonyms_behavior_implementation_class($behavior_implementation['behavior'], $field);
    $object = new $object();

    $synonyms = array_merge($synonyms, $object->extractSynonyms($items, $field, $instance, $entity, $behavior_implementation['entity_type']));
  }
  return $synonyms;
}

/**
 * Look up entities by their synonyms.
 *
 * @param QueryConditionInterface $condition
 *   Object of QueryConditionInterface that specifies conditions by which you
 *   want to find synonyms. When building this condition object, use
 *   AbstractSynonymsBehavior::COLUMN_PLACEHOLDER as a placeholder for real
 *   column name that contains synonym as text. For example, if you were to find
 *   all entities with synonyms that begin with "synonym-come-here" substring,
 *   case insensitive and replacing all spaces in original synonym string by a
 *   dash sign, then you would have to create the following condition object:
 *   db_and()
 *     ->where("LOWER(REPLACE(" . AbstractSynonymsBehavior::COLUMN_PLACEHOLDER . ", ' ', '-')) LIKE 'synonym-come-here%'")
 *   And then just supply this object as an input parameter to this function
 * @param string $entity_type
 *   Among synonyms of what entity type to search
 * @param string|array $bundle
 *   Optionally specify among synonyms of what bundle(-s) to search. You can
 *   specify here a string - bundle name to search within or an array of bundles
 *   within which to search
 *
 * @return array
 *   Array of found synonyms and entity IDs to which those belong. Each element
 *   in the array will be an object and will have the following structure:
 *   - synonym: (string) Synonym that was found and which satisfies the
 *     $condition you specified
 *   - entity_id: (int) ID of the entity to which the found synonym belongs
 */
function synonyms_synonyms_find(QueryConditionInterface $condition, $entity_type, $bundle = NULL) {
  $rows = array();

  $behavior_implementations = synonyms_behavior_get_all_enabled($entity_type, $bundle);
  foreach ($behavior_implementations as $behavior_implementation) {
    foreach (synonyms_synonyms_find_behavior($condition, $behavior_implementation) as $row) {
      $rows[] = $row;
    }
  }

  return $rows;
}

/**
 * Find entities with a provided synonym within certain behavior implementation.
 *
 * Do not use this function, if you want to find entities that have specific
 * synonyms, unless you know what you are doing. This function searches for the
 * entities with synonyms from a specific field. If you want to search for a
 * synonym among all the synonyms of an entity, use synonyms_synonyms_find().
 *
 * You have full SQL flexibility to specify parameters of how to search for
 * synonyms. You can create arbitrary set of SQL conditions that will be plugged
 * into specific SELECT queries by behavior implementations.
 *
 * @param QueryConditionInterface $condition
 *   Object of QueryConditionInterface that specifies conditions by which you
 *   want to find synonyms. When building this condition object, use
 *   AbstractSynonymsBehavior::COLUMN_PLACEHOLDER as a placeholder for real
 *   column name that contains synonym as text. For example, if you were to find
 *   all entities with synonyms that begin with "synonym-come-here" substring,
 *   case insensitive and replacing all spaces in original synonym string by a
 *   dash sign, then you would have to create the following condition object:
 *   db_and()
 *     ->where("LOWER(REPLACE(" . AbstractSynonymsBehavior::COLUMN_PLACEHOLDER . ", ' ', '-')) LIKE 'synonym-come-here%'")
 *   And then just supply this object as an input parameter to this function
 * @param array $behavior_implementation
 *   Fully loaded behavior implementation. Supply here one of the values from
 *   the return of synonyms_behavior_get() function
 *
 * @return Traversable
 *   Traversable result set of found synonyms and entity IDs to which those
 *   belong. Each element in the result set will be an object and will have the
 *   following structure:
 *   - synonym: (string) Synonym that was found and which satisfies the
 *     $condition you specified
 *   - entity_id: (int) ID of the entity to which the found synonym belongs
 */
function synonyms_synonyms_find_behavior(QueryConditionInterface $condition, $behavior_implementation) {
  $field = field_info_field($behavior_implementation['field_name']);
  $instance = field_info_instance($behavior_implementation['entity_type'], $behavior_implementation['field_name'], $behavior_implementation['bundle']);

  $object = synonyms_behavior_implementation_class($behavior_implementation['behavior'], $field);
  $object = new $object();

  return $object->synonymsFind($condition, $field, $instance);
}

/**
 * Allow to merge $synonym_entity as a synonym into $trunk_entity.
 *
 * Helpful function during various merging operations. It allows you to add a
 * synonym (where possible) into one entity, which will represent another entity
 * in the format expected by the field in which the synonym is being added.
 * Important note: if the cardinality limit of the field into which you are
 * adding synonym has been reached, calling to this function will take no
 * effect.
 *
 * @param object $trunk_entity
 *   Fully loaded entity object in which the synonym is being added
 * @param string $trunk_entity_type
 *   Entity type of $trunk_entity
 * @param string $field
 *   Field name that should exist in $trunk_entity and have enabled the
 *   "synonyms" behavior. Into this field synonym will be added
 * @param object $synonym_entity
 *   Fully loaded entity object which will be added as a synonym
 * @param string $synonym_entity_type
 *   Entity type of $synonym_entity
 *
 * @return bool
 *   Whether synonym has been successfully added
 */
function synonyms_add_entity_as_synonym($trunk_entity, $trunk_entity_type, $field, $synonym_entity, $synonym_entity_type) {
  $bundle = entity_extract_ids($trunk_entity_type, $trunk_entity);
  $bundle = $bundle[2];
  $behavior_implementations = synonyms_behavior_get_all_enabled($trunk_entity_type, $bundle, $field);

  $field = field_info_field($field);
  $instance = field_info_instance($trunk_entity_type, $field['field_name'], $bundle);
  if (empty($behavior_implementations)) {
    // $field either doesn't exist in the $trunk_entity or it does not have any
    // enabled behavior.
    return FALSE;
  }

  $items = field_get_items($trunk_entity_type, $trunk_entity, $field['field_name']);
  $items = is_array($items) ? $items : array();

  $behavior_implementation = reset($behavior_implementations);
  $object = synonyms_behavior_implementation_class($behavior_implementation['behavior'], $field);
  $object = new $object();
  $extra_items = $object->mergeEntityAsSynonym($items, $field, $instance, $synonym_entity, $synonym_entity_type);

  if (empty($extra_items)) {
    // For some reason the behavior implementation couldn't merge it. Otherwise
    // it would have not returned an empty array.
    return FALSE;
  }

  // Merging extracted synonym items into the values of the field that already
  // exist.
  // @todo: Currently we hardcode to LANGUAGE_NONE, but in future it would be
  // nice to have multilanguage support.
  $items = array_merge($items, $extra_items);

  // Now we want to keep only unique values of the $items. Since we know nothing
  // about what determines uniqueness of an item, we will ask the synonym
  // behavior to hash each of them and then will compare hashes.
  $unique_items = array();
  foreach ($items as $item) {
    $unique_items[$object->synonymItemHash($item, $field, $instance)] = $item;
  }
  $items = array_values($unique_items);

  $trunk_entity->{$field['field_name']}[LANGUAGE_NONE] = $items;

  entity_save($trunk_entity_type, $trunk_entity);
  return TRUE;
}

/**
 * Return array of field names that are sources of synonyms.
 *
 * Return array of field names that are currently have enabled the synonyms
 * behavior in the supplied vocabulary. This function is deprecated and shortly
 * will be removed from the code. All clients of this function are encourage to
 * use synonyms_behavior_get() function, which provides a richer set of
 * functionality than this one.
 *
 * @param object $vocabulary
 *   Fully loaded taxonomy vocabulary object
 *
 * @return array
 *   Array of field names
 *
 * @deprecated
 */
function synonyms_synonyms_fields($vocabulary) {
  if (!module_exists('taxonomy')) {
    return array();
  }
  $fields = array();
  $bundle = field_extract_bundle('taxonomy_term', $vocabulary);
  $behavior_implementations = synonyms_behavior_get_all_enabled('taxonomy_term', $bundle);
  foreach ($behavior_implementations as $v) {
    $fields[] = $v['field_name'];
  }
  return $fields;
}

/**
 * Implements hook_views_api().
 */
function synonyms_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'synonyms') . '/views',
  );
}

/**
 * Load function for existing implementations of synonyms behaviors.
 *
 * @param string $behavior
 *   Name of the synonyms behavior whose existing implementations should be
 *   loaded. Basically it has to be name of a ctools plugin of "behavior" type.
 * @param string $entity_type
 *   Optional filter to limit the search for existing implementations only to
 *   those that apply to the provided entity type
 * @param string|array $bundle
 *   Optional filter to limit the search for existing implementations only to
 *   those that apply to the provided bundle and entity type (the $entity_type
 *   argument). You may supply array of bundle names if you want to limit your
 *   search within a few bundles
 * @param bool $only_enabled
 *   Optional filter to limit the search for existing implementations only to
 *   those that are currently enabled
 * @param bool $include_deleted
 *   Optional filter to include the behaviors from deleted instances
 *
 * @return array
 *   Array of loaded existing synonyms behavior implementations. It is keyed
 *   by ID of the field instance to which the behavior implementation applies.
 *   The underlying array will have the following structure:
 *   - behavior: (string) Behavior name of this behavior implementation, i.e.
 *     name of a ctools plugin of "behavior" type
 *   - settings: (mixed) Behavior settings, its internal structure depends on
 *     the type of behavior. If this value is NULL, it means the behavior
 *     implementation is currently disabled for the field instance
 *   - entity_type: (string) Entity type to which this behavior implementation
 *     applies
 *   - bundle: (string) Bundle name to which this behavior implementation
 *     applies
 *   - field_name: (string) Name of a field to which this behavior
 *     implementation applies
 *   - instance_id: (int) ID of the instance to which this behavior
 *     implementation applies
 */
function synonyms_behavior_get($behavior, $entity_type = NULL, $bundle = NULL, $only_enabled = FALSE, $include_deleted = FALSE) {
  $behavior_implementation_info = synonyms_behavior_implementation_info($behavior);
  $supported_field_types = array_keys($behavior_implementation_info);

  if (empty($supported_field_types)) {
    return array();
  }

  $query = db_select('field_config_instance', 'i');
  $field_alias = $query->innerJoin('field_config', 'f', 'f.id = i.field_id');
  $query->condition($field_alias . '.type', $supported_field_types);
  if ($entity_type) {
    $query->condition('i.entity_type', $entity_type);
  }
  if ($bundle) {
    $query->condition('i.bundle', $bundle);
  }
  if (!$include_deleted) {
    $query->condition('i.deleted', 0);
  }

  $settings_alias = $query->addJoin($only_enabled ? 'INNER' : 'LEFT OUTER', 'synonyms_settings', 's', 's.instance_id = i.id AND s.behavior = :behavior', array(
    ':behavior' => $behavior,
  ));
  $query->fields($settings_alias, array('behavior', 'settings_serialized'));

  $query->fields('i', array('entity_type', 'bundle', 'field_name'));
  $query->addField('i', 'id', 'instance_id');
  $result = $query->execute();
  $result = $result->fetchAllAssoc('instance_id', PDO::FETCH_ASSOC);

  return synonyms_behavior_settings_unpack($result);
}

/**
 * Load all enabled behaviors on an entity_type and a bundle.
 *
 * This is useful when you want to do some operation on all enabled synonyms
 * behaviors for a specific entity_type and a bundle.
 *
 * @param string $entity_type
 *   Entity type whose enabled behaviors should be loaded
 * @param string|array $bundle
 *   Optionally filter by bundle whose enabled behaviors should be loaded. You
 *   can supply here string - single bundle name or an array of bundle names
 * @param string $field_name
 *   Optional filter to only return enabled synonyms behaviors of a specific
 *   field
 *
 * @return array
 *   Array of enabled behaviors for a provided entity type and a bundle. Each
 *   sub array will have the following structure:
 *   - behavior: (string) Name of the synonyms behavior
 *   - settings: (mixed) Behavior settings, its internal structure depends on
 *     the type of behavior.
 *   - entity_type: (string) Entity type to which this behavior implementation
 *     applies
 *   - bundle: (string) Bundle name to which this behavior implementation
 *     applies
 *   - field_name: (string) Name of the field on which this synonyms behavior is
 *     enabled
 *   - instance_id: (int) ID of the field instance to which this behavior
 *     implementation applies
 */
function synonyms_behavior_get_all_enabled($entity_type, $bundle = NULL, $field_name = NULL) {
  $query = db_select('synonyms_settings', 's');
  $instance_alias = $query->innerJoin('field_config_instance', 'i', 'i.id = s.instance_id');
  $query->fields($instance_alias, array('field_name', 'entity_type', 'bundle'));
  $query->fields('s', array('behavior', 'settings_serialized'));
  $query->addField($instance_alias, 'id', 'instance_id');

  $query->condition($instance_alias . '.entity_type', $entity_type);
  if ($bundle) {
    $query->condition($instance_alias . '.bundle', $bundle);
  }
  if ($field_name) {
    $query->condition($instance_alias . '.field_name', $field_name);
  }

  $result = $query->execute();
  $rows = array();
  foreach ($result as $row) {
    $rows[] = (array) $row;
  }
  return synonyms_behavior_settings_unpack($rows);
}

/**
 * Retrieve information about all ctools plugins of type 'synonyms behavior'.
 *
 * @return array
 *   Array of information on all available synonyms behavior plugins
 */
function synonyms_behaviors() {
  ctools_include('plugins');
  return ctools_get_plugins('synonyms', 'behavior');
}

/**
 * Fetch information about synonyms behaviors implementations per field type.
 *
 * Fetch the map between field types and the PHP classes that implement synonyms
 * behaviors for them.
 *
 * @param string $behavior
 *   What specific behavior is queried. Supply here keys from the return of
 *   synonyms_behaviors() function
 *
 * @return array
 *   Array of information about what field types implement the provided behavior
 *   through what PHP classes. Keys of this array are field types, whereas their
 *   values are names of PHP classes that implement the provided behavior for
 *   that particular field type
 */
function synonyms_behavior_implementation_info($behavior) {
  $info = module_invoke_all('synonyms_behavior_implementation_info', $behavior);
  drupal_alter('synonyms_behavior_implementation_info', $info, $behavior);
  return $info;
}

/**
 * Determine what PHP class implements specific behavior for specific field.
 *
 * @param string $behavior
 *   Name of the behavior, implementation of which is requested. It should be
 *   one of the keys of the return of synonyms_behaviors() function.
 * @param array $field
 *   Field definition array for which PHP class implementing $behavior is
 *   requested
 *
 * @return string
 *   Name of the PHP class that implements $behavior for $field field
 */
function synonyms_behavior_implementation_class($behavior, $field) {
  $map = synonyms_behavior_implementation_info($behavior);
  return $map[$field['type']];
}

/**
 * Execute unpacking operation on the just loaded synonyms behavior settings.
 *
 * @param array $settings
 *   Array of the just loaded settings. Each sub array should contain the
 *   following keys:
 *   - instance_id: (int) ID of the instance to which it applies
 *   - behavior: (string) name of the synonyms behavior to which these settings
 *     apply
 *   - settings_serialized: (string) serialized content of the settings
 *
 * @return array
 *   Unpacked version of the provided $settings
 */
function synonyms_behavior_settings_unpack($settings) {
  foreach ($settings as &$setting) {
    $setting['settings'] = $setting['settings_serialized'] ? unserialize($setting['settings_serialized']) : NULL;
  }
  return $settings;
}

/**
 * Save the provided synonyms behavior settings into the database.
 *
 * @param array $settings
 *   Array of settings. It must have the following structure:
 *   - instance_id: (int) ID of the instance to which it applies
 *   - behavior: (string) name of the synonyms behavior to which it applies
 *   - settings: (mixed) the content of settings themselves
 */
function synonyms_behavior_settings_save($settings) {
  if (!isset($settings['settings'])) {
    $settings['settings'] = array();
  }
  $settings['settings_serialized'] = serialize($settings['settings']);
  $result = db_merge('synonyms_settings')
    ->key(array(
      'instance_id' => $settings['instance_id'],
      'behavior' => $settings['behavior'],
    ))
    ->fields(array(
      'instance_id' => $settings['instance_id'],
      'behavior' => $settings['behavior'],
      'settings_serialized' => $settings['settings_serialized'],
    ))
    ->execute();

  switch ($result) {
    case MergeQuery::STATUS_INSERT:
      $behavior_definition = synonyms_behaviors();
      $behavior_definition = $behavior_definition[$settings['behavior']];
      $enabled_callback = ctools_plugin_get_function($behavior_definition, 'enabled callback');
      if ($enabled_callback) {
        $enabled_callback($behavior_definition, $settings['settings'], synonyms_instance_id_load($settings['instance_id']));
      }
      break;
  }
}

/**
 * Delete settings for specific behavior and field instance.
 *
 * @param int $instance_id
 *   ID of the instance for which settings should be removed
 * @param string $behavior
 *   Name of behavior for which settings should be removed
 */
function synonyms_behavior_settings_delete($instance_id, $behavior) {
  $behavior_definition = synonyms_behaviors();
  $behavior_definition = $behavior_definition[$behavior];
  $disabled_callback = ctools_plugin_get_function($behavior_definition, 'disabled callback');
  if ($disabled_callback) {
    $instance = synonyms_instance_id_load($instance_id);
    $behavior_implementation = synonyms_behavior_get($behavior, $instance['entity_type'], $instance['bundle'], TRUE, TRUE);
    if (isset($behavior_implementation[$instance_id])) {
      $behavior_implementation = $behavior_implementation[$instance_id];
      $disabled_callback($behavior_definition, $behavior_implementation, $instance);
    }
  }
  db_delete('synonyms_settings')
    ->condition('instance_id', $instance_id)
    ->condition('behavior', $behavior)
    ->execute();
}

/**
 * Supportive function to load a field instance by its ID.
 *
 * @param int $instance_id
 *   ID of the instance that should be loaded
 * @param bool $reset
 *   Whether to reset static cache of this function
 *
 * @return array
 *   Instance definition array
 */
function synonyms_instance_id_load($instance_id, $reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array(), $reset);

  if (!isset($cache[$instance_id])) {
    $cache[$instance_id] = db_select('field_config_instance', 'i')
      ->fields('i', array('entity_type', 'bundle', 'field_name'))
      ->condition('id', $instance_id)
      ->execute()
      ->fetchAssoc();
  }
  return field_info_instance($cache[$instance_id]['entity_type'], $cache[$instance_id]['field_name'], $cache[$instance_id]['bundle']);
}

/**
 * Convert synonyms friendly select widget values for storage friendly format.
 *
 * It acts similar to what the _options_form_to_storage() function does -
 * bridges between how values are returned from form API to how they are
 * expected by Field module.
 */
function synonyms_select_form_to_storage($element, &$form_state) {
  $value = array();
  if ($element['#multiple']) {
    $value = $element['#value'];
  }
  else {
    $value[] = $element['#value'];
  }

  foreach ($value as $k => $v) {
    // For the cases when a synonym was selected and not an entity option, we
    // process the selected values stripping everything that goes after
    // semicolon.
    if (!is_numeric($v)) {
      $id = explode(':', $v);
      $value[$k] = $id[0];
    }
  }

  // The user also might have selected multiple times the same entity, given
  // that an entity can be represented by more than 1 option (an entity and its
  // synonym), then it's possible in theory, so we should be ready for this
  // scenario.
  $value = array_unique($value);

  $form_state_value = array();
  foreach ($value as $id) {
    $form_state_value[] = array($element['#columns'][0] => $id);
  }

  form_set_value($element, $form_state_value, $form_state);
}

/**
 * Check whether a taxonomy term $tid is a child of a taxonomy term $parent_tid.
 *
 * Supportive function, used throughout this module for parent constrains.
 *
 * @param int $tid
 *   {taxonomy_term}.tid of the term that is tested for being a child of the
 *   $parent_tid term
 * @param int $parent_tid
 *   {taxonomy_term}.tid of the term that is tested for being parent of the $tid
 *   term
 *
 * @return bool
 *   Whether $tid is a child of $parent_tid
 */
function synonyms_taxonomy_term_is_child_of($tid, $parent_tid) {
  $term_parents = taxonomy_get_parents_all($tid);

  // Dropping out the term itself from its array of parents.
  array_shift($term_parents);

  foreach ($term_parents as $term_parent) {
    if ($term_parent->tid == $parent_tid) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Format an option for entity reference select form element.
 *
 * @param object $entity
 *   Fully loaded entity which is represented by this option
 * @param string $entity_type
 *   Entity type of the $entity object
 * @param string $synonym
 *   If the provided entity is represented in this option by a synonym, then
 *   provide it here
 * @param array $behavior_implementation
 *   Behavior implementation array from which the $synonym comes from
 * @param array $options
 *   Array of additional settings or options that may influence execution of
 *   this function. Currently supported options are:
 *   - depth: Whether to prefix wording of option labels with depth of the
 *     entity. This will work only for taxonomy term entities, as they are the
 *     only ones that have notion of depth
 *
 * @return object
 *   An option for entity reference select form element
 */
function synonyms_select_option_entity($entity, $entity_type, $synonym = NULL, $behavior_implementation = NULL, $options = array()) {
  $entity_id = entity_extract_ids($entity_type, $entity);
  $entity_id = $entity_id[0];
  $key = $synonym ? $entity_id . ':' . drupal_html_class($synonym) : $entity_id;
  $wording = entity_label($entity_type, $entity);
  if ($synonym) {
    $instance = field_info_instance($behavior_implementation['entity_type'], $behavior_implementation['field_name'], $behavior_implementation['bundle']);
    $wording = format_string($behavior_implementation['settings']['wording'], array(
      '@synonym' => $synonym,
      '@entity' => entity_label($behavior_implementation['entity_type'], $entity),
      '@field_name' => drupal_strtolower($instance['label']),
    ));
  }

  if (in_array('depth', $options) && $entity_type == 'taxonomy_term') {
    $depth = count(taxonomy_get_parents_all($entity_id)) - 1;
    $wording = str_repeat('-', $depth) . $wording;
  }

  return (object) array(
    'option' => array($key => $wording),
  );
}

/**
 * Supportive function to build taxonomy term options array sorted by name.
 *
 * The function starts from the 0-depth level and starts to recursively build
 * the options and to sort the labels on each level, then it merges the bottom
 * to up all the levels maintaining correct order within the final options
 * array.
 *
 * @param object $vocabulary
 *   Within which vocabulary to execute the function. Supply here the fully
 *   loaded taxonomy vocabulary object
 * @param int $parent
 *   Only children of this term will be included in the output. You can supply
 *   0 which means to include all the terms from the vocabulary
 * @param int $depth
 *   Used for internal purposes. Clients of this function should supply here 0,
 *   unless they know what they are doing. It is used internally to keep track
 *   of the nesting level
 *
 * @return array
 *   Array of options that can be inserted directly into 'select' form element.
 *   The options will be sorted by name (term or synonym), respecting the
 *   hierarchy restrictions
 */
function synonyms_select_taxonomy_term_sort_name_options_recursive($vocabulary, $parent = 0, $depth = 0) {
  // We statically cache behavior implementations in order to not DDOS the data
  // base.
  $behavior_implementations = &drupal_static(__FUNCTION__, array());

  $bundle = field_extract_bundle('taxonomy_term', $vocabulary);
  if (!isset($behavior_implementations[$bundle])) {
    $behavior_implementations[$bundle] = synonyms_behavior_get('select', 'taxonomy_term', $bundle, TRUE);
  }

  $options = array();
  if ($terms = taxonomy_get_tree($vocabulary->vid, $parent, 1, TRUE)) {
    $options = array();
    foreach ($terms as $term) {
      $term->depth = $depth;
      $options[] = synonyms_select_option_entity($term, 'taxonomy_term', NULL, NULL, array('depth'));
      foreach ($behavior_implementations[$bundle] as $implementation) {
        foreach (synonyms_extract_synonyms($term, $implementation) as $synonym) {
          $options[] = synonyms_select_option_entity($term, 'taxonomy_term', $synonym, $implementation, array('depth'));
        }
      }
    }

    usort($options, 'synonyms_select_sort_name');

    // Now recursively go one level nested into each of the terms that we have
    // on this level.
    $options_copy = $options;
    $i = 0;
    foreach ($options_copy as $v) {
      $i++;
      $tid = array_keys($v->option);
      $tid = $tid[0];
      if (is_numeric($tid)) {
        $nested_options = synonyms_select_taxonomy_term_sort_name_options_recursive($vocabulary, $tid, $depth + 1);
        $options = array_merge(array_slice($options, 0, $i), $nested_options, array_slice($options, $i));
      }
    }
  }
  return $options;
}

/**
 * Supportive function.
 *
 * It is used for string comparison within synonyms friendly select widget.
 */
function synonyms_select_sort_name($a, $b) {
  return strcasecmp(reset($a->option), reset($b->option));
}

/**
 * Test if entity type is applicable for having synonyms.
 *
 * Only fieldable entity types can have synonyms for the very reason that
 * synonyms are stored in fields.
 *
 * @param string $entity_type
 *   Entity type to test
 *
 * @return bool|string
 *   Whether the provided entity type is applicable for having synonyms. If it
 *   is applicable, the $entity_type input argument will be returned. Otherwise
 *   FALSE is returned
 */
function synonyms_entity_type_load($entity_type) {
  $entity_info = entity_get_info($entity_type);
  if ($entity_info && $entity_info['fieldable']) {
    return $entity_type;
  }
  return FALSE;
}

/**
 * Test if provided entity type and bundle exist.
 *
 * @param string $bundle
 *   Bundle name to test for existence
 * @param string $entity_type
 *   Entity type to test for existence
 *
 * @return bool|string
 *   Whether the provided entity type and bundle exist. If they exist, the
 *   $bundle input argument is returned. Otherwise FALSE is returned
 */
function synonyms_bundle_load($bundle, $entity_type) {
  $entity_info = entity_get_info($entity_type);
  if ($entity_info && isset($entity_info['bundles'][$bundle])) {
    return $bundle;
  }
  return FALSE;
}

/**
 * Menu title callback function for synonyms settings page.
 *
 * @param string $entity_type
 *   Entity type whose synonyms settings are managed
 * @param string $bundle
 *   Bundle whose synonyms settings are managed
 *
 * @return string
 *   Title of the synonyms settings page
 */
function synonyms_settings_title($entity_type, $bundle) {
  $entity_info = entity_get_info($entity_type);
  $entity_label = isset($entity_info['plural label']) ? $entity_info['plural label'] : $entity_info['label'];
  if ($entity_type == $bundle) {
    return t('Synonyms settings of @entity_type', array(
      '@entity_type' => $entity_label,
    ));
  }
  return t('Synonyms settings of @bundle @entity_type', array(
    '@bundle' => $entity_info['bundles'][$bundle]['label'],
    '@entity_type' => $entity_label,
  ));
}

/**
 * Escape string to safely use in autocomplete text field as default value.
 *
 * @param string $value
 *   String to be escaped
 *
 * @return string
 *   Escaped string $value
 */
function synonyms_autocomplete_escape($value) {
  // Commas or quotes must be wrapped in quotes.
  if (strpos($value, ',') !== FALSE || strpos($value, '"') !== FALSE) {
    $value = '"' . str_replace('"', '""', $value) . '"';
  }
  return $value;
}

/**
 * Determine a list of target bundles of an entityreference field.
 *
 * @param array $field
 *   Field definition array. This field must be of type 'entityreference'
 *
 * @return array|null
 *   List of target bundles per the settings of provided field or NULL if the
 *   provided field does not expose any limitations on target bundles
 */
function synonyms_field_target_bundles($field) {
  $target_bundles = isset($field['settings']['handler_settings']['target_bundles']) ? array_values($field['settings']['handler_settings']['target_bundles']) : array();
  if (empty($target_bundles)) {
    $target_bundles = NULL;
  }
  return $target_bundles;
}
